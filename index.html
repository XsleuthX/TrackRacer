<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Heat: Pedal to the Metal — Core Rules Web Simulator (Unofficial)</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#121a24; --panel2:#0f1620; --text:#e8f0ff; --muted:#9fb0c8;
    --accent:#5bd6ff; --warn:#ffce5b; --bad:#ff5b74; --good:#7dff9b;
    --line:#233246; --chip:#1b2738;
    --radius:14px;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#070a0f,#0b0f14);color:var(--text);}
  header{
    position:sticky;top:0;z-index:50;
    display:flex;gap:12px;align-items:center;justify-content:space-between;
    padding:10px 14px;background:rgba(10,14,20,.86);backdrop-filter: blur(8px);
    border-bottom:1px solid var(--line);
  }
  header .left{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  header .right{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
  .title{font-weight:800;letter-spacing:.2px}
  .pill{padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:rgba(255,255,255,.03);color:var(--muted);font-size:12px}
  .btn{cursor:pointer;border:1px solid var(--line);background:rgba(255,255,255,.03);color:var(--text);
    padding:8px 10px;border-radius:10px;font-weight:700;font-size:13px;}
  .btn:hover{border-color:#34506f}
  .btn.primary{background:rgba(91,214,255,.12);border-color:rgba(91,214,255,.35)}
  .btn.danger{background:rgba(255,91,116,.12);border-color:rgba(255,91,116,.35)}
  .btn.good{background:rgba(125,255,155,.12);border-color:rgba(125,255,155,.35)}
  .btn:disabled{opacity:.45;cursor:not-allowed}
  .btn.small{padding:6px 8px;font-size:12px;border-radius:9px}
  input,select,textarea{background:rgba(255,255,255,.03);color:var(--text);border:1px solid var(--line);border-radius:10px;padding:8px 10px}
  input[type="color"]{padding:0;border:none;background:none;width:42px;height:32px}
  textarea{width:100%;min-height:120px;resize:vertical}
  .app{display:grid;grid-template-columns: 1.45fr 1fr;gap:12px;padding:12px;min-height:calc(100vh - 60px)}
  .panel{background:rgba(18,26,36,.86);border:1px solid var(--line);border-radius:var(--radius);overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,.25)}
  .panel .hd{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid var(--line);background:rgba(255,255,255,.02)}
  .panel .hd h2{margin:0;font-size:14px;letter-spacing:.2px}
  .panel .bd{padding:12px}
  .grid2{display:grid;grid-template-columns: 1fr 1fr;gap:10px}
  .grid3{display:grid;grid-template-columns: 1fr 1fr 1fr;gap:10px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .muted{color:var(--muted)}
  .small{font-size:12px}
  .hr{height:1px;background:var(--line);margin:10px 0}

  /* Track */
  .trackWrap{display:flex;flex-direction:column;height:100%}
  .trackTools{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .trackView{
    position:relative;
    height:calc(100% - 48px);
    overflow:auto;
    background:linear-gradient(180deg, rgba(255,255,255,.01), rgba(255,255,255,0));
  }
  .trackGrid{
    display:grid;
    grid-auto-flow:column;
    grid-auto-columns: var(--spaceW, 92px);
    gap:8px;
    padding:12px;
    align-items:start;
    min-height:420px;
  }
  .space{
    border:1px solid var(--line);
    border-radius:14px;
    background:rgba(255,255,255,.02);
    padding:8px;
    display:flex;
    flex-direction:column;
    gap:8px;
    min-height:120px;
    position:relative;
  }
  .space .idx{font-size:11px;color:var(--muted);display:flex;justify-content:space-between;gap:6px}
  .badge{font-size:10px;padding:2px 6px;border-radius:999px;border:1px solid var(--line);background:rgba(255,255,255,.03);color:var(--muted)}
  .badge.finish{border-color:rgba(125,255,155,.4);background:rgba(125,255,155,.10);color:#bfffd0}
.badge.press{background:rgba(255,110,205,.14);border-color:rgba(255,110,205,.33);color:rgba(255,190,235,.95);}
  .badge.corner{border-color:rgba(255,206,91,.45);background:rgba(255,206,91,.10);color:#ffe7b0}
  .spots{display:grid;grid-template-rows: 1fr 1fr;gap:6px;flex:1}
  .spots.one{grid-template-rows: 1fr}
  .spot{
    border:1px dashed rgba(159,176,200,.35);
    border-radius:12px;
    min-height:40px;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    background:rgba(255,255,255,.015);
  }
  .spot.raceline{border-style:solid;border-color:rgba(91,214,255,.25)}
  .car{
    width:30px;height:30px;border-radius:10px;
    display:flex;align-items:center;justify-content:center;
    font-weight:900;font-size:12px;
    box-shadow:0 10px 25px rgba(0,0,0,.35);
    border:1px solid rgba(255,255,255,.25);
  }
  .car.ai::after{content:"AI";position:absolute;bottom:-12px;font-size:9px;color:var(--muted)}
  .carWrap{position:relative;display:flex;align-items:center;justify-content:center}

  /* Cards */
  .hand{display:flex;flex-wrap:wrap;gap:8px}
  .card{
    width:62px;height:84px;border-radius:12px;border:1px solid var(--line);
    background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.01));
    padding:8px;display:flex;flex-direction:column;justify-content:space-between;
    cursor:pointer;user-select:none;
  }
  .card:hover{border-color:#3a5676}
  .card.disabled{opacity:.4;cursor:not-allowed}
  .card.selected{outline:2px solid rgba(91,214,255,.65);border-color:rgba(91,214,255,.45)}
  .card .top{display:flex;justify-content:space-between;align-items:center;gap:6px}
  .card .val{font-size:20px;font-weight:1000;letter-spacing:-.5px}
  .card .tag{font-size:10px;color:var(--muted);padding:2px 6px;border:1px solid var(--line);border-radius:999px;background:rgba(0,0,0,.12)}
  .card .btm{display:flex;justify-content:space-between;align-items:center}
  .sym{font-weight:900}
  .sym.plus{color:var(--accent)}
  .sym.heat{color:var(--bad)}
  .sym.cool{color:var(--good)}
  .sym.stress{color:var(--warn)}

  /* Upgrade visibility */
  .upgLabel{font-size:10px;line-height:1.1;color:var(--text);opacity:.9;max-width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .upgList{display:flex;flex-direction:column;gap:8px;margin-top:8px}
  .upgItem{border:1px solid var(--line);border-radius:12px;background:rgba(0,0,0,.12);padding:8px}
  .upgDesc{margin:6px 0 0 0;white-space:pre-wrap;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:11px;color:var(--muted)}

  /* Log */
  .log{max-height:200px;overflow:auto;border:1px solid var(--line);border-radius:12px;background:rgba(0,0,0,.18);padding:10px}
  .log .item{font-size:12px;color:var(--muted);margin:0 0 8px 0}
  .log .item strong{color:var(--text)}

  /* Modal */
  .modalBack{
    position:fixed;inset:0;background:rgba(0,0,0,.6);
    display:none;align-items:center;justify-content:center;z-index:100;
  }
  .modalBack.show{display:flex}
  .modal{
    width:min(860px, 92vw);
    max-height:86vh;
    overflow:auto;
    background:rgba(18,26,36,.95);
    border:1px solid var(--line);
    border-radius:18px;
    box-shadow:0 40px 120px rgba(0,0,0,.5);
  }
  .modal .mh{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid var(--line)}
  .modal .mb{padding:12px}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:12px;color:#cfe3ff}
  .note{padding:10px;border:1px solid var(--line);border-radius:12px;background:rgba(255,255,255,.03);color:var(--muted)}
  .tag2{font-size:11px;padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.04);border:1px solid var(--line);color:var(--muted)}
  .warn{color:#ffe1a3}
  .goodTxt{color:#c7ffd5}
  .badTxt{color:#ffb1bd}

  /* Responsive */
  @media (max-width: 980px){
    .app{grid-template-columns:1fr;}
    .trackView{height:auto;min-height:420px}
  }

/* --- Garage Draft cards --- */
.market{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:10px;margin-top:8px;}
.cardBtn{cursor:pointer;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:10px;text-align:left;min-height:110px;transition:transform .08s ease,border-color .08s ease;}
.cardBtn:hover{transform:translateY(-1px);border-color:rgba(165,220,255,.35);}
.cardBtn:disabled{opacity:.55;cursor:not-allowed;transform:none;}
.cardFace{display:flex;flex-direction:column;gap:6px;}
.cardTitle{font-weight:800;font-size:12px;letter-spacing:.2px;}
.cardBody{white-space:pre-line;font-size:12px;color:rgba(255,255,255,.78);line-height:1.25;}

/* --- Track tokens (Weather/Road) --- */
.trackTokens{position:sticky;top:0;z-index:5;margin:0 0 8px 0;padding:8px 10px;border:1px solid rgba(255,255,255,.10);border-radius:14px;background:rgba(12,15,22,.75);backdrop-filter: blur(6px);}
.trackTokens .row{align-items:flex-start;}
.trackTokens .tokLine{font-size:12px;color:rgba(255,255,255,.8);line-height:1.25;}
.badge.road{background:rgba(255,190,92,.16);border-color:rgba(255,190,92,.35);color:rgba(255,230,190,.95);}
.badge.sector{background:rgba(120,210,255,.14);border-color:rgba(120,210,255,.33);color:rgba(215,245,255,.95);}

  /* --- Track Map View (original visual treatment) --- */
  .trackCanvas{
    width:100%;
    height:520px;
    display:block;
    border:1px solid var(--line);
    border-radius:var(--radius);
    background:
      radial-gradient(1200px 600px at 70% 60%, rgba(255,255,255,0.05), transparent 60%),
      linear-gradient(135deg, rgba(255,190,120,0.10), rgba(255,120,90,0.06)),
      repeating-linear-gradient(0deg, rgba(255,255,255,0.045) 0 1px, transparent 1px 24px),
      repeating-linear-gradient(90deg, rgba(255,255,255,0.045) 0 1px, transparent 1px 24px),
      #1a1410;
    box-shadow:0 18px 45px rgba(0,0,0,0.35) inset, 0 10px 30px rgba(0,0,0,0.25);
  }
  .trackViewModeHint{
    font-size:12px; color:var(--muted);
  }
  .badgeMap{
    position:absolute;
    pointer-events:none;
  }


  .tbl{width:100%;border-collapse:collapse;font-size:13px}
  .tbl th,.tbl td{border-bottom:1px solid rgba(255,255,255,0.14);padding:6px 8px;text-align:left}
  .tbl th{color:rgba(255,255,255,0.72);font-weight:700}
</style>
</head>
<body>
<header>
  <div class="left">
    <div class="title">Heat: Pedal to the Metal — Core Rules Web Simulator <span class="pill">Unofficial • no art/assets</span></div>
    <div class="pill" id="phasePill">Phase: Setup</div>
    <div class="pill" id="seedPill">Seed: —</div>
  </div>
  <div class="right">
    <button class="btn small" id="btnUndo" title="Undo last action">Undo</button>
    <button class="btn small" id="btnSave">Save</button>
    <label class="btn small" for="fileLoad" style="display:inline-flex;align-items:center;gap:8px">Load</label>
    <input id="fileLoad" type="file" accept="application/json" style="display:none" />
    <button class="btn small" id="btnTrackEditor">Track Editor</button>
    <button class="btn small" id="btnHelp">Help</button>
    <button class="btn danger small" id="btnNew">New Game</button>
  </div>
</header>

<div class="app">
  <section class="panel trackWrap">
    <div class="hd">
      <h2>Track</h2>
      <div class="trackTools">
        <span class="tag2">Zoom</span>
        <input id="zoom" type="range" min="68" max="140" value="92" />
        <span class="tag2">View</span>
        <select id="trackViewMode">
          <option value="map" selected>Map</option>
          <option value="strip">Strip</option>
        
</select>
<span class="tag2">Path</span>
        <button class="btn small" id="btnPathEdit" title="Edit the race line path to match your background image. Drag points. Shift+Click adds a point. Alt+Click deletes a point.">Edit</button>
        <button class="btn small" id="btnPathReset" title="Reset the path to the preset default for this track.">Reset</button>
        <span class="small muted" id="pathStatus"></span>
                <span class="tag2">BG</span>
        <button class="btn small" id="btnBgLoad" title="Load a background image for the current track (local file).">Load</button>
        <button class="btn small" id="btnBgClear" title="Clear background image for the current track.">Clear</button>
        <span class="small muted" id="bgStatus">(none)</span>
        <span class="tag2">Opacity</span>
        <input id="bgOpacity" type="range" min="0" max="100" value="85" style="width:110px" />
        <span class="tag2">Scale</span>
        <input id="bgScale" type="range" min="50" max="200" value="100" style="width:110px" />
        <span class="tag2">X</span>
        <input id="bgDx" type="range" min="-50" max="50" value="0" style="width:90px" />
        <span class="tag2">Y</span>
        <input id="bgDy" type="range" min="-50" max="50" value="0" style="width:90px" />
        <input id="trackBgFile" type="file" accept="image/*" style="display:none" />

        <span class="tag2">Auto-scroll</span>
        <select id="autoScroll">
          <option value="on" selected>On</option>
          <option value="off">Off</option>
        </select>
        <button class="btn small" id="btnCenter">Center on Active</button>
      </div>
    </div>
    <div class="trackView" id="trackView">
      <div class="trackTokens" id="trackTokens"></div>
      <canvas class="trackCanvas" id="trackCanvas"></canvas>
      <div class="trackGrid" id="trackGrid"></div>
    </div>
  </section>

  <section class="panel">
    <div class="hd">
      <h2 id="rightTitle">Setup</h2>
      <div class="row">
        <span class="tag2" id="turnTag">—</span>
      </div>
    </div>
    <div class="bd" id="rightPanel"></div>
  </section>

  <section class="panel" style="grid-column: 1 / -1;">
    <div class="hd">
      <h2>Race Control Log</h2>
      <div class="row">
        <button class="btn small" id="btnClearLog">Clear</button>
      </div>
    </div>
    <div class="bd">
      <div class="log" id="log"></div>
    </div>
  </section>
</div>

<!-- Modal -->
<div class="modalBack" id="modalBack" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="mh">
      <div class="row" style="gap:10px;align-items:center">
        <strong id="modalTitle">Modal</strong>
        <span class="pill" id="modalSub" style="display:none"></span>
      </div>
      <button class="btn small" id="modalClose">Close</button>
    </div>
    <div class="mb" id="modalBody"></div>
  </div>
</div>

<script>
(() => {
  "use strict";

  /***********************
   * RNG (seeded)
   ***********************/
  function xmur3(str){
    let h = 1779033703 ^ str.length;
    for (let i=0;i<str.length;i++){
      h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
      h = (h << 13) | (h >>> 19);
    }
    return function(){
      h = Math.imul(h ^ (h >>> 16), 2246822507);
      h = Math.imul(h ^ (h >>> 13), 3266489909);
      return (h ^= (h >>> 16)) >>> 0;
    }
  }
  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
  }

  /***********************
   * Utilities
   ***********************/
  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const deepClone = (obj) => JSON.parse(JSON.stringify(obj));

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function uid(prefix="c"){
    return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  }

  function downloadText(filename, text, mime="text/plain"){
    const blob = new Blob([text], {type:mime});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
  }

  function fmtCard(c){
    if (!c) return "—";
    if (c.type === 'basic') return `Basic ${c.value}`;
    if (c.type === 'upgrade') return c.name ? `U${c.upgNum||''} ${c.name} (${c.value})` : `Upgrade ${c.value}`;
    if (c.type === 'sponsor') return c.name ? `Sponsor ${c.choices?('[?]'):(c.value)} (${c.name})` : `Sponsor ${c.value}`;
    if (c.type === 'stress') return c.revealedCard ? `Stress (+→Basic ${c.revealedCard.value})` : `Stress (+)`;
    if (c.type === 'heat') return `Heat`;
    return c.type;
  }


  function cardTooltip(c){
    if (!c) return "—";
    let t = fmtCard(c);
    if (c.type === 'upgrade' || (c.type==='heat' && c.origin==='upgrade')){
      t += "\n" + upgradeCardFaceText(c);
    }
    if (c.type === 'sponsor'){
      t += "\n" + (c.desc || 'One-time sponsorship card. Removed after being played.');
      if (c.slipBonus) t += `\nSlipstream +${c.slipBonus}`;
      if (c.cool) t += `\nCooldown +${c.cool}`;
      if (c.limitMod) t += `\nCorner Limit +${c.limitMod}`;
      if (c.choices) t += `\nChoose speed: ${c.choices.join('/')}`;
    }
    return t;
  }

  function renderUpgradeDetailsFromHand(hand){
    const upgs = (hand||[]).filter(c => c.type==='upgrade' || c.type==='sponsor' || (c.type==='heat' && c.origin==='upgrade'));
    if (!upgs.length) return '';
    function sponsorText(c){
      const lines = [];
      if (c.desc) lines.push(c.desc);
      if (c.slipBonus) lines.push(`Slipstream +${c.slipBonus} (this turn)`);
      if (c.limitMod) lines.push(`Corner Speed Limit +${c.limitMod} (this turn)`);
      if (c.cool) lines.push(`Cooldown +${c.cool} (optional)`);
      if (c.choices) lines.push(`Choose speed: ${c.choices.join('/')}`);
      return lines.join('\n');
    }
    return `
      <div class="note small" style="margin-top:10px">
        <strong>Special cards in hand</strong>
        <div class="small muted">Upgrade / Sponsorship reference (Advanced + Championship).</div>
        <div class="upgList">
          ${upgs.map(c=>{
            let title='', body='';
            if (c.type==='upgrade'){
              title = `U${c.upgNum} ${c.name}`;
              body = upgradeCardFaceText(c);
            } else if (c.type==='sponsor'){
              const v = c.choices ? `(${c.choices.join('/')})` : `(${c.value})`;
              title = `S ${c.name} ${v}`;
              body = sponsorText(c);
            } else {
              title = `Heat (Upgrade effect)`;
              body = 'This Heat card was created by an upgrade effect and clogs your hand like normal Heat.';
            }
            return `<div class="upgItem">
              <div style="font-weight:850">${escapeHtml(title)}</div>
              <pre class="upgDesc">${escapeHtml(body||'')}</pre>
            </div>`;
          }).join('')}
        </div>
      </div>
    `;
  }
  /***********************
   * Rules helpers (from official core rules PDF)
   * - Basic deck: 3x(1..4)
   * - Starting upgrades: 0, 5, and 1 Heat-in-deck
   * - Start: typically 6 Heat in engine + 3 Stress in deck; board defines counts.
   ***********************/

  function makeBasicDeck(color){
    const cards = [];
    for (let v=1; v<=4; v++){
      for (let i=0;i<3;i++) cards.push({id:uid(`b${v}`), type:'basic', value:v, owner:color});
    }
    return cards;
  }

  function makeStartingUpgrades(color){
    // Two are 0 and 5 (act like basic), but are discarded when flipped for symbol effects.
    // Third is an extra Heat card shuffled into deck at start.
    return [
      {id:uid('u0'), type:'upgrade', value:0, owner:color, upgradeKind:'start'},
      {id:uid('u5'), type:'upgrade', value:5, owner:color, upgradeKind:'start'},
      {id:uid('uh'), type:'heat', value:0, owner:color, upgradeKind:'start-in-deck'},
    ];
  }

  function makeStressCards(n, owner){
    const arr=[];
    for (let i=0;i<n;i++) arr.push({id:uid('s'), type:'stress', value:0, owner});
    return arr;
  }

  function makeHeatCards(n, owner){
    const arr=[];
    for (let i=0;i<n;i++) arr.push({id:uid('h'), type:'heat', value:0, owner});
    return arr;
  }

  function shuffleInPlace(arr, rngFn){
    const rf = (typeof rngFn === 'function') ? rngFn : (typeof rng === 'function' ? rng : Math.random);
    for (let i=arr.length-1;i>0;i--){
      const j = Math.floor(rf()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // Convenience wrapper used by some modules
  function shuffle(arr, rngFn){
    shuffleInPlace(arr, rngFn);
  }

  /***********************
   * Default track preset (functional, original)
   ***********************/
  const DEFAULT_TRACK = {
    id: "demo",
    name: "Desert Sprint (demo)",
    spacesCount: 60,
    spotsPerSpace: 2,
    finishIndex: 0,
    lapsRequired: 2,
    corners: [
      {cornerLineIndex: 12, speedLimit: 7},
      {cornerLineIndex: 28, speedLimit: 6},
      {cornerLineIndex: 45, speedLimit: 8}
    ],
    startGridStartIndex: 2,

    // Map View polyline (relative points 0..1). Original, not copied from any official board.
    mapPoly: [
      [0.14,0.80],[0.82,0.80],[0.92,0.72],[0.92,0.22],[0.72,0.18],[0.54,0.26],
      [0.58,0.52],[0.44,0.62],[0.30,0.52],[0.36,0.34],[0.24,0.22],[0.12,0.30],[0.10,0.52],[0.14,0.80]
    ],
    mapTheme: "desert"
  };

  // Track presets (schematic, no official art). Names match the base game's 4 official tracks.
  // Use Track Editor to match your physical board exactly.
  const TRACK_LIBRARY = [
    { id:"demo", name:"Demo — Desert Sprint", track: DEFAULT_TRACK },

    { id:"usa", name:"USA (schematic)", track: {
      id:"usa", name:"USA (schematic)",
      "spacesCount": 69, "spotsPerSpace": 2, "finishIndex": 0, "lapsRequired": 2,
  "corners": [
    { "cornerLineIndex": 14, "speedLimit": 7 }, { "cornerLineIndex": 33, "speedLimit": 3 },
    { "cornerLineIndex": 50, "speedLimit": 3 }, { "cornerLineIndex": 59, "speedLimit": 2 }],
  "startGridStartIndex": 2,
  "mapPoly": [
    [ 0.6674874407415269, 0.18741976893453144 ], [ 0.6756385763815185, 0.18356867779204109 ],
    [ 0.7997169744569448, 0.1797175866495507  ], [ 0.9029646925635039, 0.2926829268292683  ],
    [ 0.9699851411589896, 0.7355584082156611  ], [ 0.9337578716479162, 0.8921694480102695  ],
    [ 0.8594919691502159, 0.938382541720154   ], [ 0.34687610556852755, 0.9255455712451861 ],
    [ 0.1449090780442935, 0.9486521181001284  ], [ 0.06973749380881625, 0.865211810012837  ],
    [ 0.11773862591098846, 0.7625160462130937 ], [ 0.22008066227977074, 0.7124518613607189 ],
    [ 0.28619542913747964, 0.55198973042362   ], [ 0.3369136064529824, 0.28498074454428757 ],
    [ 0.42657609849288897, 0.07958921694480103], [ 0.4908795018750442, 0.08087291399229782 ],
    [ 0.5325408618127786, 0.18613607188703465 ], [ 0.3668011037996179, 0.5866495507060334  ],
    [ 0.43382155239510367, 0.637997432605905  ], [ 0.5352579070261091, 0.38767650834403083 ],
    [ 0.6176749451638011, 0.23491655969191272 ], [ 0.6674874407415269, 0.18741976893453144 ]
  ],
  "mapTheme": "desert"
    }},

    { id:"france", name:"France (schematic)", track: {
      id:"france", name:"France (schematic)",
      "spacesCount": 60,
  "spotsPerSpace": 2,
  "finishIndex": 0,
  "lapsRequired": 2,
  "startGridStartIndex": 2,
  "corners": [
    { "cornerLineIndex": 12, "speedLimit": 5 },
    { "cornerLineIndex": 20, "speedLimit": 2 },
    { "cornerLineIndex": 27, "speedLimit": 4 },
    { "cornerLineIndex": 39, "speedLimit": 3 },
    { "cornerLineIndex": 47, "speedLimit": 4 }
  ],
  "mapPoly": [
    [ 0.4908795018750442, 0.889602053915276    ], [ 0.39125451071959244, 0.8690629011553274  ],
    [ 0.3015920186796858, 0.8087291399229781   ], [ 0.1920045284086889, 0.6598202824133504   ],
    [ 0.14943748673317767, 0.5532734274711169  ], [ 0.09600226420434445, 0.4672657252888318  ],
    [ 0.09600226420434445, 0.36970474967907574 ], [ 0.14038066935540933, 0.30166880616174585 ],
    [ 0.1947215736220194, 0.2952503209242619   ], [ 0.26808179438194296, 0.251604621309371   ],
    [ 0.3432533786174202, 0.19127086007702182  ], [ 0.3803863298662704, 0.13478818998716302  ],
    [ 0.43653859760843416, 0.20282413350449294 ], [ 0.3450647420929739, 0.355584082156611    ],
    [ 0.2979692917285785, 0.46983311938382544  ], [ 0.3034033821552395, 0.5840821566110398   ],
    [ 0.35412155947074225, 0.6495507060333762  ], [ 0.4057454185240218, 0.6405648267008985   ],
    [ 0.45736927757730134, 0.5994865211810013  ], [ 0.5098988183683577, 0.5391527599486521   ],
    [ 0.5542772235194227, 0.4544287548138639   ], [ 0.5977499469327107, 0.3170731707317073   ],
    [ 0.5950329017193802, 0.24261874197689345  ], [ 0.590504493030496, 0.17329910141206675   ],
    [ 0.6249203990660157, 0.10654685494223363  ], [ 0.6846953937592868, 0.10141206675224647  ],
    [ 0.716394254581476, 0.14377406931964057   ], [ 0.7408476615014505, 0.2913992297817715   ],
    [ 0.7779806127503007, 0.3478818998716303   ], [ 0.8875681030212976, 0.3940949935815148   ],
    [ 0.9219840090568174, 0.5096277278562259   ], [ 0.885756739545744, 0.5879332477535302    ],
    [ 0.7200169815325833, 0.8010269576379975   ], [ 0.606806764310479, 0.8767650834403081    ],
    [ 0.4908795018750442, 0.889602053915276    ]
  ],
  "mapTheme": "euro"
    }},

    { id:"italy", name:"Italy (schematic)", track: {
      id:"italy", name:"Italy (schematic)",
       "spacesCount": 54,
  "spotsPerSpace": 2,
  "finishIndex": 0,
  "lapsRequired": 2,
  "startGridStartIndex": 2,
  "corners": [
    { "cornerLineIndex": 10, "speedLimit": 5 },
    { "cornerLineIndex": 19, "speedLimit": 2 },
    { "cornerLineIndex": 26, "speedLimit": 3 }
  ],
  "mapPoly": [
    [ 0.7901347470099881, 0.364461738002594   ], [ 0.8075103953817355, 0.5214007782101168  ],
    [ 0.7919637626280668, 0.6446173800259404  ], [ 0.6840518411614249, 0.8132295719844358  ],
    [ 0.5889430290213338, 0.9247730220492867  ], [ 0.5258419901976195, 0.9053177691309987  ],
    [ 0.49749224811739995, 0.8326848249027238 ], [ 0.4270751468213709, 0.3865110246433204  ],
    [ 0.3612305845705386, 0.41115434500648507 ], [ 0.36214509237957787, 0.4474708171206226 ],
    [ 0.3987254047411514, 0.6705577172503242  ], [ 0.4225026077761742, 0.8132295719844358  ],
    [ 0.40146892816826946, 0.8754863813229572 ], [ 0.36397410799765656, 0.9156939040207522 ],
    [ 0.3209922409728077, 0.8962386511024644  ], [ 0.2908134832745095, 0.8067444876783398  ],
    [ 0.2322849834959919, 0.4150453955901427  ], [ 0.23594301473214924, 0.311284046692607  ],
    [ 0.26246374119429006, 0.2127107652399481 ], [ 0.33013731906320104, 0.125810635538262  ],
    [ 0.4005544203592301, 0.08300907911802853 ], [ 0.5130388808710686, 0.06614785992217899 ],
    [ 0.6621036537444808, 0.10505836575875487 ], [ 0.7389223097037853, 0.20233463035019456 ],
    [ 0.7901347470099881, 0.364461738002594   ]
  ],
  "mapTheme": "euro"
    }},

    { id:"gb", name:"Great Britain (schematic)", track: {
      id:"gb", name:"Great Britain (schematic)",
      "spacesCount": 63,
  "spotsPerSpace": 2,
  "finishIndex": 0,
  "lapsRequired": 2,
  "startGridStartIndex": 2,
  "corners": [
    { "cornerLineIndex": 15, "speedLimit": 10 },
    { "cornerLineIndex": 30, "speedLimit": 6  },
    { "cornerLineIndex": 37, "speedLimit": 5  },
    { "cornerLineIndex": 43, "speedLimit": 4  },
    { "cornerLineIndex": 48, "speedLimit": 3  }
  ],
  "mapPoly": [
    [ 0.2926424988925882, 0.2230869001297017  ], [ 0.3401969049626338, 0.11932555123216602 ],
    [ 0.4096994984496235, 0.0648508430609598  ], [ 0.8340311218438764, 0.0648508430609598  ],
    [ 0.9044482231399054, 0.10116731517509728 ], [ 0.943772058928597,  0.17380025940337224 ],
    [ 0.949259105782833,  0.3022049286640726  ], [ 0.9346269808382036, 0.4487678339818418  ],
    [ 0.9071917465670234, 0.6355382619974059  ], [ 0.8495777545975451, 0.7989623865110247  ],
    [ 0.7773316376834374, 0.9130998702983139  ], [ 0.7270337081862738, 0.920881971465629   ],
    [ 0.6794793021162282, 0.8845654993514915  ], [ 0.6621036537444808, 0.8313878080415046  ],
    [ 0.6602746381264021, 0.7444876783398184  ], [ 0.6822228255433462, 0.6212710765239948  ],
    [ 0.7160596144778018, 0.5356679636835279  ], [ 0.703256505151251,  0.4565499351491569  ],
    [ 0.6666761927896775, 0.4293125810635538  ], [ 0.6209508023377106, 0.437094682230869   ],
    [ 0.5770544275038224, 0.48638132295719844 ], [ 0.519440435534344,  0.5071335927367056  ],
    [ 0.4801165997456525, 0.5019455252918288  ], [ 0.4444507951931183, 0.5421530479896238  ],
    [ 0.4225026077761742, 0.5875486381322957  ], [ 0.4508523498563937, 0.6783398184176395  ],
    [ 0.5404741151422489, 0.7146562905317769  ], [ 0.6054041695840419, 0.7782101167315175  ],
    [ 0.570652872840547,  0.874189364461738   ], [ 0.5258419901976195, 0.8404669260700389  ],
    [ 0.43073317805752825, 0.7769130998702983 ], [ 0.36031607676149924, 0.7185473411154345 ],
    [ 0.29904405355586355, 0.6342412451361867 ], [ 0.2560621865310147, 0.4889753566796368  ],
    [ 0.2560621865310147, 0.377431906614786   ], [ 0.2926424988925882, 0.2230869001297017  ]
  ],
  "mapTheme": "classic"
    }},

    { id:"custom", name:"Custom (your edits)", track: null }
  ];


  function normalizeTrack(t){
    const out = deepClone(t);
    out.spacesCount = clamp(parseInt(out.spacesCount||0,10), 10, 200);
    out.spotsPerSpace = (parseInt(out.spotsPerSpace||2,10) === 1) ? 1 : 2;
    out.finishIndex = clamp(parseInt(out.finishIndex||0,10), 0, out.spacesCount-1);
    out.lapsRequired = clamp(parseInt(out.lapsRequired||2,10), 1, 9);
    out.startGridStartIndex = clamp(parseInt(out.startGridStartIndex ?? 2,10), 0, out.spacesCount-1);
    out.corners = Array.isArray(out.corners) ? out.corners.map(c => ({
      cornerLineIndex: clamp(parseInt(c.cornerLineIndex||0,10), 0, out.spacesCount-1),
      speedLimit: clamp(parseInt(c.speedLimit||0,10), 1, 20)
    })).sort((a,b)=>a.cornerLineIndex-b.cornerLineIndex) : [];
    // Merge duplicates by keeping the first.
    const seen=new Set();
    out.corners = out.corners.filter(c => {
      if (seen.has(c.cornerLineIndex)) return false;
      seen.add(c.cornerLineIndex); return true;
    });
    // Optional Map View layout + theme (purely cosmetic)
    if (Array.isArray(out.mapPoly)){
      out.mapPoly = out.mapPoly
        .filter(p => Array.isArray(p) && p.length>=2)
        .map(p => [clamp(+p[0],0,1), clamp(+p[1],0,1)]);
      if (out.mapPoly.length < 4) out.mapPoly = null;
    } else {
      out.mapPoly = null;
    }
    out.mapTheme = (out.mapTheme || out.mapTheme===0) ? String(out.mapTheme) : null;

    return out;
  }


  
  // Track selection + persistence:
  // - Selecting a preset stores its id
  // - Track Editor edits are stored as "custom"
  const TRACK_SELECTED_KEY = 'heat.trackPresetId.v1';
  const TRACK_CUSTOM_KEY   = 'heat.customTrack.v2';

  // Multiple saved custom track presets
  const TRACK_CUSTOM_PRESETS_KEY = 'heat.customTrackPresets.v1';

  function loadCustomPresets(){
    try{
      const raw = localStorage.getItem(TRACK_CUSTOM_PRESETS_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return [];
      // Normalize shape
      return arr
        .filter(x => x && typeof x.id==='string' && x.track)
        .map(x => ({
          id: String(x.id),
          name: String(x.name || x.track?.name || x.id),
          track: normalizeTrack(x.track)
        }));
    }catch(e){
      return [];
    }
  }

  function saveCustomPresets(list){
    try{
      localStorage.setItem(TRACK_CUSTOM_PRESETS_KEY, JSON.stringify(list));
    }catch(e){}
  }

  function isUserPresetId(id){
    if (!id || id==='custom') return false;
    const list = loadCustomPresets();
    return list.some(p => p.id === id);
  }

  function makeUserPresetId(){
    // Deterministic enough for local storage; still unique in practice
    return 'u_' + Date.now().toString(36) + '_' + Math.floor((Math.random()*1e9)).toString(36);
  }

  function getAllPresets(){
    const builtIns = (TRACK_LIBRARY||[]).filter(p => p && p.id && p.id !== 'custom');
    const customs = loadCustomPresets();
    return [...builtIns, ...customs];
  }



  function getInitialTrackPresetId(){
    try{
      return localStorage.getItem(TRACK_SELECTED_KEY) || 'demo';
    }catch(e){
      return 'demo';
    }
  }

  function getPresetById(id){
    return (getAllPresets()||[]).find(p => p.id === id) || null;
  }

  function loadCustomTrack(){
    try{
      const raw = localStorage.getItem(TRACK_CUSTOM_KEY);
      if (!raw) return normalizeTrack(DEFAULT_TRACK);
      return normalizeTrack(JSON.parse(raw));
    }catch(e){
      return normalizeTrack(DEFAULT_TRACK);
    }
  }

  function getInitialTrack(){
    const pid = getInitialTrackPresetId();
    if (pid === 'custom') return loadCustomTrack();
    const preset = getPresetById(pid);
    if (preset && preset.track) return normalizeTrack(preset.track);
    return normalizeTrack(DEFAULT_TRACK);
  }

  function setTrack(nextTrack, {persist=true, remapPositions=true, presetId=null} = {}){
    // Guard: championship or setup may call setTrack(null) before a preset is chosen
    if (!nextTrack){
      try{
        nextTrack = (typeof structuredClone === 'function') ? structuredClone(DEFAULT_TRACK) : JSON.parse(JSON.stringify(DEFAULT_TRACK));
      }catch(e){
        nextTrack = DEFAULT_TRACK;
      }
    }
    const nt = normalizeTrack(nextTrack);
    G.track = nt;

    // Persist selected preset id + custom track json (if applicable)
    if (persist){
      try{
        const pid = presetId || G.trackPresetId || 'custom';
        localStorage.setItem(TRACK_SELECTED_KEY, pid);
        if (pid === 'custom'){
          localStorage.setItem(TRACK_CUSTOM_KEY, JSON.stringify(nt));
        }
      }catch(e){}
    }

    // Remember current selection in-state
    if (presetId) G.trackPresetId = presetId;
    if (!G.trackPresetId) G.trackPresetId = 'custom';

    // Apply any saved map path override for this track preset
    applyPolyOverrideToCurrentTrack();

    if (remapPositions && Array.isArray(G.players)){
      const N = nt.spacesCount;
      for (const p of G.players){
        if (!p || !p.pos) continue;
        p.pos.idx = ((p.pos.idx % N) + N) % N;
        p.pos.lane = (nt.spotsPerSpace===1) ? 0 : clamp(p.pos.lane,0,1);
      }
    }

    // Changing track invalidates module token placement & draft state.
    G.weatherRoad = null;
    G.draft = null;
    return nt;
  }


/***********************
   * Game State
   ***********************/
  const PHASE = {
    SETUP: 'setup',
    DRAFT: 'draft',
    PLANNING: 'planning',
    RESOLUTION: 'resolution',
    FINISHED: 'finished'
  };

  // Resolution sub-steps for active car
  const STEP = {
    REVEAL_MOVE: 'reveal_move',
    ADRENALINE: 'adrenaline',
    REACT: 'react',
    SLIPSTREAM: 'slipstream',
    CHECK_CORNER: 'check_corner',
    DISCARD: 'discard',
    REPLENISH: 'replenish',
    DONE: 'done'
  };

  let G = null;
  let rng = null;

  // --- Track background images (local-only; not bundled) ---
  const BG_STORE_KEY = 'heat_track_bg_by_track';
  // Stored as { [trackKey]: {dataUrl, w, h, opacity, scale, dx, dy} }
  let trackBgByTrack = {};
  const bgImgCache = new Map(); // trackKey -> Image

  // --- Track map polyline overrides (per track, local-only; not bundled) ---
  const POLY_STORE_KEY = 'heat_track_poly_by_track';
  // Stored as { [trackKey]: {mapPoly:[[x,y],...]} }
  let trackPolyByTrack = {};

  function loadPolyStore(){
    try{
      const raw = localStorage.getItem(POLY_STORE_KEY);
      if (raw) trackPolyByTrack = JSON.parse(raw) || {};
    }catch(e){ trackPolyByTrack = {}; }
  }
  function persistPolyStore(){
    try{ localStorage.setItem(POLY_STORE_KEY, JSON.stringify(trackPolyByTrack)); }
    catch(e){ /* ignore */ }
  }
  function getPolyOverride(){
    return trackPolyByTrack[trackKey()]?.mapPoly || null;
  }
  function setPolyOverride(mapPoly){
    const k = trackKey();
    if (!mapPoly){
      delete trackPolyByTrack[k];
    } else {
      trackPolyByTrack[k] = { mapPoly: mapPoly };
    }
    persistPolyStore();
  }
  function applyPolyOverrideToCurrentTrack(){
    if (!G || !G.track) return;
    const ov = getPolyOverride();
    if (Array.isArray(ov) && ov.length>=4){
      G.track.mapPoly = deepClone(ov);
    }
  }

  // --- Map path editing state ---
  let mapEditEnabled = false;
  let mapDragIndex = -1;
  let mapDragging = false;


  function trackKey(){
    return (G && (G.trackPresetId || G.track?.name)) || 'custom';
  }
  function loadBgStore(){
    try{
      const raw = localStorage.getItem(BG_STORE_KEY);
      if (raw) trackBgByTrack = JSON.parse(raw) || {};
    }catch(e){ trackBgByTrack = {}; }
  }
  function persistBgStore(){
    try{ localStorage.setItem(BG_STORE_KEY, JSON.stringify(trackBgByTrack)); }
    catch(e){ /* ignore quota errors */ }
  }
  function getTrackBg(){
    return trackBgByTrack[trackKey()] || null;
  }
  function setTrackBg(bg){
    const k = trackKey();
    if (!bg){
      delete trackBgByTrack[k];
      bgImgCache.delete(k);
      persistBgStore();
      updateBgUI();
      renderTrack();
      return;
    }
    trackBgByTrack[k] = bg;
    persistBgStore();
    updateBgUI();
    renderTrack();
  }
  function updateBgUI(){
    const st = $('#bgStatus');
    const op = $('#bgOpacity');
    const sc = $('#bgScale');
    const dx = $('#bgDx');
    const dy = $('#bgDy');
    const bg = getTrackBg();
    if (st){
      st.textContent = bg ? `loaded (${Math.round((bg.w||0))}×${Math.round((bg.h||0))})` : '(none)';
    }
    if (op){ op.disabled = !bg; op.value = bg ? String(Math.round((bg.opacity??0.85)*100)) : '85'; }
    if (sc){ sc.disabled = !bg; sc.value = bg ? String(Math.round((bg.scale??1.0)*100)) : '100'; }
    if (dx){ dx.disabled = !bg; dx.value = bg ? String(Math.round((bg.dx??0)*100)) : '0'; }
    if (dy){ dy.disabled = !bg; dy.value = bg ? String(Math.round((bg.dy??0)*100)) : '0'; }
  }

  let history = [];

  function pushHistory(reason){
    if (!G) return;
    history.push({snap: deepClone(G), reason, t: Date.now()});
    if (history.length > 60) history.shift();
    updateUndoBtn();
  }

  function undo(){
    if (!history.length) return;
    const last = history.pop();
    G = last.snap;
    // Rebuild rng to current seed/stream index.
    rng = makeRng(G.seed, G.rngCalls);
    log(`Undo: ${last.reason}`);
    renderAll();
    updateUndoBtn();
  }

  function makeRng(seedStr, callCount=0){
    const seedFn = xmur3(seedStr);
    const r = mulberry32(seedFn());
    // burn calls
    for (let i=0;i<callCount;i++) r();
    const wrap = () => {
      G.rngCalls++;
      return r();
    };
    return wrap;
  }

  function newGame(){
    const seed = ("seed-" + Math.random().toString(16).slice(2,10));
    G = {
      version: 1,
      modules: {garage:false, weatherRoad:false, championship:false, upgradePool:'basic'},
      weatherRoad: null,
      draft: null,
      champ: null,
      champConfig: {enabled:false, races:4, schedulePreset:'mix', points:[10,6,4,3,2,1], startSponsorship:1, pressCornersMode:'first'},
      seed,
      rngCalls: 0,
      phase: PHASE.SETUP,
      trackPresetId: getInitialTrackPresetId(),
      track: getInitialTrack(),
      players: [],
      startedCount: 0,
      planningIdx: 0,
      round: 1,
      resolveOrder: [],
      resolveIdx: 0,
      activeStep: STEP.REVEAL_MOVE,
      adrenaline: {eligible:false, move:false, cooldownBonus:0},
      cornerCrossed: [],
      speedForCorner: 0,
      crossedFinishFinal: false,
      finishedOrder: [],
      log: []
    };
    rng = makeRng(G.seed, 0);
    history = [];
    updateSeedPill();
    pushHistory("Start new game");
    renderAll();
  }

  /***********************
   * Logging
   ***********************/
  function log(msg){
    if (!G) return;
    const line = `[R${G.round}] ${msg}`;
    G.log.push({t:Date.now(), line});
    const el = document.createElement('p');
    el.className = 'item';
    el.innerHTML = escapeHtml(line).replace(/\[(R\d+)\]/, '<strong>[$1]</strong>');
    const box = $('#log');
    box.appendChild(el);
    // Auto-scroll to bottom so the newest events appear last (chronological reading).
    box.scrollTop = box.scrollHeight;
  }

  function escapeHtml(s){
    return (s+"").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function rebuildLog(){
    const box = $('#log');
    box.innerHTML = '';
    // Render chronologically: oldest at top, newest at bottom.
    (G.log||[]).forEach(e => {
      const p=document.createElement('p');
      p.className='item';
      p.innerHTML = escapeHtml(e.line).replace(/\[(R\d+)\]/, '<strong>[$1]</strong>');
      box.appendChild(p);
    });
    box.scrollTop = box.scrollHeight;
  }

  /***********************
   * Player helpers
   ***********************/
  function makePlayer({name, color, isAI=false, heatInEngine=6, stressInDeck=3, useStartingUpgrades=true, drawStartHand=true}){
    const basic = makeBasicDeck(color);
    const stress = makeStressCards(stressInDeck, color);
    let deck = [...basic, ...stress];

    if (useStartingUpgrades){
      const upg = makeStartingUpgrades(color);
      // Keep same ordering as earlier build: insert 3 starting upgrades into the deck
      deck = [...basic, upg[0], upg[1], ...stress, upg[2]];
    }

    shuffleInPlace(deck, rng);

    const p = {
      id: uid('p'),
      name: name || color,
      color,
      isAI,
      gear: 1,
      engine: makeHeatCards(heatInEngine, color),
      deck,
      discard: [],
      hand: [],
      play: [],
      boostUsed: false,
      pos: {idx: 0, lane: 0},
      lap: 0,
      finished: false,
      removedFromTrack: false,
      finishRank: null,
      planned: {gearTarget: 1, payHeatForShift: false, cards: []},
      publicTopDiscard: null,
      // Advanced module per-turn info
      _upgCooldownBonus: 0,
    };

    if (drawStartHand){
      for (let i=0;i<7;i++) p.hand.push(drawFromDeck(p, {allowReshuffle:true}));
      p.publicTopDiscard = topOf(p.discard);
    }

    return p;
  }

  function topOf(arr){ return arr.length ? arr[arr.length-1] : null; }

  function drawFromDeck(p, {allowReshuffle=true}={}){
    if (!p.deck.length){
      if (!allowReshuffle) return null;
      if (p.discard.length){
        // shuffle discard into deck
        const newDeck = p.discard.splice(0, p.discard.length);
        shuffleInPlace(newDeck, rng);
        p.deck = newDeck;
      }
    }
    return p.deck.pop() || null;
  }

  function discardCards(p, cards){
    for (const c of cards){
      if (!c) continue;
      p.discard.push(c);
    }
    p.publicTopDiscard = topOf(p.discard);
  }

  function payHeat(p, n){
    const paid = Math.min(n, p.engine.length);
    const moved = p.engine.splice(0, paid);
    discardCards(p, moved);
    return paid;
  }

  function addStressToHand(p, n){
    const stress = makeStressCards(n, p.color);
    // In the physical game, stress comes from a finite reserve; for this simulator we treat as effectively available.
    p.hand.push(...stress);
  }

  function cardCanBePlayed(c){
    return c && c.type !== 'heat';
  }

  function isNonDiscardable(c){
    // Core rules: cannot choose to discard Stress or Heat cards (even upgrade ones).
    return c && (c.type === 'heat' || c.type === 'stress');
  }

  /***********************
   * Track / movement
   ***********************/
  function carSortKey(p){
    // Car ordering on a looped track:
    // progress = laps completed * spaces + distance since last crossing the finish line.
    const N = G.track.spacesCount;
    const dist = (p.pos.idx - G.track.finishIndex + N) % N;
    const progress = (p.lap * N) + dist;
    // Within same space, race line (lane 0) is ahead.
    return (progress * 10) + (p.pos.lane === 0 ? 1 : 0);
  }

  function sortedCars(frontToBack=true, includeFinished=false){
    const arr = G.players.filter(p => includeFinished ? true : !p.finished);
    arr.sort((a,b)=>{
      const da = carSortKey(a);
      const db = carSortKey(b);
      if (db !== da) return frontToBack ? (db - da) : (da - db);
      // stable fallback: by original order
      return G.players.indexOf(a) - G.players.indexOf(b);
    });
    return arr;
  }

  function occupiedAt(idx){
    const occ=[null,null];
    for (const p of G.players){
      if (p.removedFromTrack) continue;
      if (p.pos.idx === idx){
        occ[p.pos.lane] = p;
      }
    }
    return occ;
  }

  function isSpaceFull(idx){
    const occ = occupiedAt(idx);
    const spots = G.track.spotsPerSpace;
    if (spots === 1) return !!occ[0];
    return !!occ[0] && !!occ[1];
  }

  function findBestSpot(idx){
    const spots = G.track.spotsPerSpace;
    const occ = occupiedAt(idx);
    if (spots === 1){
      return occ[0] ? null : {idx, lane:0};
    }
    if (!occ[0]) return {idx, lane:0};
    if (!occ[1]) return {idx, lane:1};
    return null;
  }

  function placeWithBlocking(p, targetIdx){
    // Cars may pass through cars, but cannot end on fully occupied space.
    const N = G.track.spacesCount;
    let idx = ((targetIdx % N) + N) % N;
    let spot = findBestSpot(idx);
    if (spot) return spot;
    // Find first space with free spot behind the blocking cars.
    for (let back=1; back<=N; back++){
      const j = (idx - back + N) % N;
      spot = findBestSpot(j);
      if (spot) return spot;
    }
    // Should never happen
    return {idx, lane:0};
  }

  function stepForward(idx){
    const N = G.track.spacesCount;
    return (idx + 1) % N;
  }

  function crossesCornerOnEnter(spaceIdx){
    // Corner line at a specific index.
    return (G.track.corners || []).find(c => c.cornerLineIndex === spaceIdx) || null;
  }

  function moveSteps(p, steps, opts={}){
    // opts: {countCorners:true, allowFinishCross:true, forbidCrossFinish:false}
    const N = G.track.spacesCount;
    const countCorners = opts.countCorners ?? true;
    const allowFinishCross = opts.allowFinishCross ?? true;
    const forbidCrossFinish = opts.forbidCrossFinish ?? false;

    let cornerCrossed = [];
    let crossedFinishFinal = false;

    let idx = p.pos.idx;
    let lane = p.pos.lane;

    for (let s=0; s<steps; s++){
      let next = stepForward(idx);

      // Handle finish crossing
      if (next === G.track.finishIndex){
        if (forbidCrossFinish){
          // stop before crossing
          break;
        }
        if (allowFinishCross){
          // Crossing the finish line increments lap when entering finishIndex
          p.lap += 1;
          if (p.lap >= G.track.lapsRequired){
            crossedFinishFinal = true;
          }
        }
      }

      idx = next;

      if (countCorners && !crossedFinishFinal){
        const corner = crossesCornerOnEnter(idx);
        if (corner) cornerCrossed.push(corner);
      }

      // If crossedFinishFinal, corners after finish are disregarded (per core rules).
    }

    // Place with blocking at resulting idx
    const placed = placeWithBlocking(p, idx);
    p.pos.idx = placed.idx;
    p.pos.lane = placed.lane;
    return {cornerCrossed, crossedFinishFinal};
  }

  function moveExact(p, distance, opts={}){
    // Moves forward by distance, applying stepwise finish/corner tracking and then blocking placement.
    const res = moveSteps(p, distance, opts);
    return res;
  }

  /***********************
   * Turn flow
   ***********************/
  function ensurePlanning(){
    if (G.phase !== PHASE.PLANNING) return;
    // If current planning player is AI, auto-plan.
    const p = G.players[G.planningIdx];
    if (!p || p.finished) {
      advancePlanningIdx();
      return;
    }
    if (p.isAI){
      pushHistory(`AI plan: ${p.name}`);
      aiPlan(p);
      p.planned.locked = true;
      log(`${p.name} (AI) locks in gear ${p.gear} with ${p.planned.cards.length} card(s).`);
      advancePlanningIdx();
    }
  }

  function advancePlanningIdx(){
    // Move to next not-finished player who isn't locked.
    let tries = 0;
    const n = G.players.length;
    while (tries < n){
      G.planningIdx = (G.planningIdx + 1) % n;
      tries++;
      const p = G.players[G.planningIdx];
      if (p && !p.finished && !p.planned.locked) break;
    }
    // If all locked, begin resolution
    if (G.players.filter(p => !p.finished).every(p => p.planned.locked)){
      startResolution();
    }
    renderAll();
    ensurePlanning();
  }

  function startPlanning(){
    G.phase = PHASE.PLANNING;
    G.planningIdx = 0;
    for (const p of G.players){
      p.boostUsed = false;
      p.play = [];
      p.planned = {gearTarget: p.gear, payHeatForShift:false, cards:[], locked:false};
    }
    log(`Planning begins for Round ${G.round}. (Gears + cards)`);
    renderAll();
    ensurePlanning();
  }

  function startResolution(){
    G.phase = PHASE.RESOLUTION;
    // Determine resolve order by current positions (frontmost first)
    // Robust: store player indices, unique, excluding removed-from-track cars.
    for (const pl of G.players){
      pl._resolvedThisRound = false;
    }
    const order = sortedCars(true,false)
      .filter(pp => !pp.removedFromTrack)
      .map(pp => G.players.indexOf(pp));
    // De-duplicate while preserving order
    G.resolveOrder = Array.from(new Set(order));
    G.resolveIdx = 0;
    G.activeStep = STEP.REVEAL_MOVE;
    G.cornerCrossed = [];
    G.speedForCorner = 0;
    G.crossedFinishFinal = false;
    G.adrenaline = {eligible:false, move:false, cooldownBonus:0};

    // Adrenaline eligibility based on number of cars that started the race (core rules mention start count)
    // Core rules: last car to move, or last two cars in race with 5+ cars.
    const started = G.startedCount || G.players.length;
    const lastCount = (started >= 5) ? 2 : 1;
    const backOrder = sortedCars(true,false); // front->back
    const eligibleIds = backOrder.slice(-lastCount).map(p=>p.id);
    G._adrenalineEligibleIds = eligibleIds;

    log(`Resolution begins. Order: ${backOrder.map(p=>p.name).join(' → ')}`);
    renderAll();
    ensureResolutionAI();
  }

  function activePlayer(){
    const token = G.resolveOrder[G.resolveIdx];
    if (token === undefined || token === null) return null;
    // Backward compatible: resolveOrder can store either player indices (number) or ids (string)
    if (typeof token === 'number'){
      return G.players[token] || null;
    }
    return G.players.find(p => p.id === token) || null;
  }

  function ensureResolutionAI(){
    if (G.phase !== PHASE.RESOLUTION) return;
    const p = activePlayer();
    if (!p || p.removedFromTrack) return;
    if (!p.isAI) return;
    // For AI in resolution, auto-pick choices (adrenaline, boost, slipstream, discard)
    // We execute step-by-step as if clicking "Next" repeatedly.
    // To keep UI responsive, we still require user to click Next to proceed, but auto-decide within steps.
  }

  function nextStep(){
    if (!G) return;
    if (G.phase === PHASE.PLANNING){
      // In planning, Next means lock current player's choices
      const p = G.players[G.planningIdx];
      if (!p || p.finished) { advancePlanningIdx(); return; }
      if (p.isAI) return; // AI auto
      if (!p.planned.cards || p.planned.cards.length !== p.gear){
        toast(`Select exactly ${p.gear} card(s) to play (no Heat).`);
        return;
      }
      pushHistory(`Lock in: ${p.name}`);
      p.planned.locked = true;
      log(`${p.name} locks in gear ${p.gear} with ${p.planned.cards.length} card(s).`);
      advancePlanningIdx();
      return;
    }

    if (G.phase === PHASE.RESOLUTION){
      const p = activePlayer();
      if (!p){
        // Safety: if resolve order got corrupted, rebuild remaining cars instead of skipping them.
        if (rebuildResolutionOrderForRemaining()){
          renderAll();
          autoResolveAIIfNeeded();
        }
        return;
      }
      // If the active player is AI, avoid running the full manual step machine (prevents double-advancing when users click Next).
      // Clicking Next during an AI turn triggers deterministic AI progression.
      if (p.isAI){
        // Ensure AI still performs its Reveal & Move when needed.
        if (G.activeStep === STEP.REVEAL_MOVE){
          pushHistory(`AI Reveal & Move: ${p.name}`);
          const outcome = doRevealAndMove(p);
          G.activeStep = (outcome && outcome.nextStep) ? outcome.nextStep : STEP.ADRENALINE;
          renderAll();
        }
        autoResolveAIIfNeeded();
        return;
      }
      // Skip cars removed from track
      if (p.removedFromTrack){
        advanceResolutionIdx();
        return;
      }

      switch (G.activeStep){
        case STEP.REVEAL_MOVE:
          pushHistory(`Reveal & Move: ${p.name}`);
          const outcome = doRevealAndMove(p);
          G.activeStep = (outcome && outcome.nextStep) ? outcome.nextStep : STEP.ADRENALINE;
          break;
        case STEP.ADRENALINE:
          pushHistory(`Adrenaline decision: ${p.name}`);
          doAdrenaline(p);
          G.activeStep = STEP.REACT;
          break;
        case STEP.REACT:
          pushHistory(`End React: ${p.name}`);
          endReact(p);
          G.activeStep = STEP.SLIPSTREAM;
          break;
        case STEP.SLIPSTREAM:
          if (G._slipPending){
            toast("Choose Slipstream (or skip), then click Next.");
            return;
          }
          pushHistory(`End Slipstream: ${p.name}`);
          endSlipstream(p);
          G.activeStep = STEP.CHECK_CORNER;
          break;
        case STEP.CHECK_CORNER:
          pushHistory(`Check Corner: ${p.name}`);
          doCheckCorner(p);
          G.activeStep = STEP.DISCARD;
          break;
        case STEP.DISCARD:
          if (G._discardPending){
            toast("Select discardable cards (not Heat/Stress) then click 'Confirm Discard'.");
            return;
          }
          pushHistory(`Discard step: ${p.name}`);
          // discard handled by button; if none, proceed
          G.activeStep = STEP.REPLENISH;
          break;
        case STEP.REPLENISH:
          pushHistory(`Replenish: ${p.name}`);
          doReplenish(p);
          // After replenishing, immediately advance to the next car (hotseat flow).
          // advanceResolutionIdx() already triggers render + AI auto-resolve where relevant.
          advanceResolutionIdx();
          return;

case STEP.DONE:
          advanceResolutionIdx();
          break;
        default:
          advanceResolutionIdx();
      }
      renderAll();
      // If AI, auto-resolve its choice points.
      autoResolveAIIfNeeded();
      return;
    }
  }

  
function resetPerCarGlobals(){
  G.activeStep = STEP.REVEAL_MOVE;
  G.cornerCrossed = [];
  G.speedForCorner = 0;
  G.crossedFinishFinal = false;
  G.adrenaline = {eligible:false, move:false, cooldownBonus:0};
  G._reactPending = false;
  G._slipPending = false;
  G._discardPending = false;
}

function rebuildResolutionOrderForRemaining(){
  if (!G || G.phase !== PHASE.RESOLUTION) return false;
  // Find any players who have NOT completed replenish this round (and are not finished/removed).
  const remaining = G.players
    .map((p, idx)=>({p, idx}))
    .filter(o => !o.p.finished && !o.p.removedFromTrack && !o.p._resolvedThisRound);

  if (!remaining.length) return false;

  remaining.sort((a,b)=>{
    const da = carSortKey(a.p);
    const db = carSortKey(b.p);
    if (db !== da) return db - da; // frontmost first
    return a.idx - b.idx;
  });

  G.resolveOrder = remaining.map(o=>o.idx);
  G.resolveIdx = 0;
  resetPerCarGlobals();
  log(`(Fix) Resolution order repaired for remaining cars: ${remaining.map(o=>o.p.name).join(' → ')}`);
  return true;
}

function advanceResolutionIdx(){
    // End current player's turn, move to next in order
    G.resolveIdx++;
    resetPerCarGlobals();

    if (G.resolveIdx >= G.resolveOrder.length){
      // Safety: if some cars somehow didn't get resolved, rebuild the resolution order instead of ending the round.
      if (rebuildResolutionOrderForRemaining()){
        renderAll();
        autoResolveAIIfNeeded();
        return;
      }
      // End of round: remove finished cars from track (but keep state)
      endOfRoundCleanup();
      if (G.players.every(p => p.finished)){
        G.phase = PHASE.FINISHED;
        log(`Race finished!`);
      } else {
        G.round++;
        // Reset planning locks
        for (const p of G.players){
          if (p.finished) continue;
          p.planned.locked = false;
          p.planned.cards = [];
        }
        startPlanning();
      }
    }
    renderAll();
    autoResolveAIIfNeeded();
  }

  function endOfRoundCleanup(){
    // Remove finished cars from the track only at the END of a round (not immediately when they cross).
    // This matters for blocking + slipstream during the round.
    for (const p of G.players){
      if (p.finished && !p.removedFromTrack){
        p.removedFromTrack = true;
      }
    }
  }

  /***********************
   * Core mechanics
   ***********************/
  function applyShift(p, gearTarget){
    gearTarget = clamp(gearTarget, 1, 4);
    const delta = gearTarget - p.gear;
    if (delta === 0){ p.gear = gearTarget; return {ok:true, paid:0}; }
    if (Math.abs(delta) === 1){ p.gear = gearTarget; return {ok:true, paid:0}; }
    if (Math.abs(delta) === 2){
      // Pay 1 heat immediately
      if (p.engine.length <= 0) return {ok:false, reason:"No Heat in engine to shift 2."};
      payHeat(p, 1);
      p.gear = gearTarget;
      return {ok:true, paid:1};
    }
    return {ok:false, reason:"You may shift at most 2 gears."};
  }

  function resolveStressIntoBasic(p){
    // Flip cards until a Basic card appears. Non-basic are discarded.
    while (true){
      const c = drawFromDeck(p, {allowReshuffle:true});
      if (!c) return null;
      if (c.type === 'basic'){
        return c;
      }
      // Upgrades are discarded when flipped for symbol effects.
      discardCards(p, [c]);
    }
  }

  function doRevealAndMove(p){
  // Re-enterable if a human must choose a variable Speed (Brakes) value.
  if (!p._revealPrepared){
    p.boostUsed = false;
    G.cornerCrossed = [];
    G.speedForCorner = 0;
    G.crossedFinishFinal = false;

    // Per-turn upgrade modifiers / symbol counters
    p._turnSlipBonus = 0;
    p._turnLimitMod = 0;
    p._symbolsAppliedCount = 0; // upgrade symbols actually applied during React
    p._plusSymbolsResolved = 0;

    // Transfer planned cards into play area
    p.play = p.planned.cards.map(id => {
      const i = p.hand.findIndex(c => c.id === id);
      if (i >= 0) return p.hand.splice(i,1)[0];
      return null;
    }).filter(Boolean);

    // Cluttered hand rule
    if (p.play.length < p.gear){
      const need = p.gear - p.play.length;
      const heats = [];
      for (let k=0;k<need;k++){
        const hi = p.hand.findIndex(c => c.type === 'heat');
        if (hi >= 0) heats.push(p.hand.splice(hi,1)[0]);
      }
      p.play.push(...heats);
      log(`${p.name} has a cluttered hand and cannot play enough cards. No movement; gear drops to 1.`);
      p.gear = 1;
      discardCards(p, p.play.splice(0,p.play.length));
      G.cornerCrossed = [];
      G.speedForCorner = 0;
      G.crossedFinishFinal = false;
      p._revealPrepared = false;
      p._revealProcessed = false;
      return { nextStep: STEP.REPLENISH };
    }

    // Mandatory Heat-cost upgrades: enforce immediately (pragmatic to avoid retroactive movement issues).
    // If cannot pay, discard the Upgrade and replace it with a random Basic (as with a "+" symbol).
    for (let i=0;i<p.play.length;i++){
      const c = p.play[i];
      if (!c || (c.type !== 'upgrade' && c.type !== 'sponsor')) continue;
      if (c.payHeatCost && c.payHeatCost > 0){
        if (p.engine.length >= c.payHeatCost){
          payHeat(p, c.payHeatCost);
          log(`${p.name} pays ${c.payHeatCost} Heat to use ${c.label||c.name}.`);
        } else {
          log(`${p.name} cannot pay Heat cost for ${c.label||c.name}. Discards it and flips a replacement speed card.`);
          p.play.splice(i,1);
          discardCards(p, [c]);
          const repl = resolveStressIntoBasic(p);
          if (repl){ p.play.push(repl); }
          i--;
        }
      }
    }

    // Resolve all boost symbols from Stress and from Upgrade "+" icons.
    // Per advanced rules: first count printed Speed numbers, then resolve "+" symbols, then choose variable-speed upgrades.
    // Stress behaves like a "+" symbol: flip until Basic appears, add that speed.
    // 1) Stress cards: attach revealed Basic to the Stress card
    for (let i=0;i<p.play.length;i++){
      const c = p.play[i];
      if (c.type === 'stress' && !c.revealedCard){
        const basic = resolveStressIntoBasic(p);
        if (basic){
          c.revealedCard = basic;
        }
      }
    }

    // 2) Upgrade "+" icons: flip that many Basics; keep them attached to the Upgrade and in play until replenish.
    for (const c of p.play){
      if (!c || (c.type !== 'upgrade' && c.type !== 'sponsor')) continue;
      c.plusCards = c.plusCards || [];
      if (c.plus && c.plus > 0){
        for (let k=0;k<c.plus;k++){
          const b = resolveStressIntoBasic(p);
          if (!b) break;
          c.plusCards.push(b);
          p.play.push(b);
          p._plusSymbolsResolved++;
        }
      }
    }

    p._revealPrepared = true;
    p._revealProcessed = true;
    p._movedThisReveal = false;
  }

  // Compute subtotal after Stress/+ boosts resolved, before choosing any variable-speed upgrade values.
  const subtotal = p.play.reduce((sum,c)=>{
    if (!c) return sum;
    if (c.type === 'stress') return sum + (c.revealedCard ? (c.revealedCard.value||0) : 0);
    if (c.type === 'upgrade' || c.type === 'sponsor'){
      const plus = (c.plusCards||[]).reduce((s,x)=>s+(x.value||0),0);
      if (c.choices && (c.chosen==null)) return sum + plus; // variable chosen later
      const base = (c.choices ? (c.chosen||0) : (c.value||0));
      return sum + base + plus;
    }
    return sum + (c.value||0);
  }, 0);
  p._baseSpeedNoVar = subtotal;

  // Choose variable-speed upgrades ("Brakes") AFTER Stress/+ have been resolved.
  const nextVar = p.play.find(c => c && (c.type==='upgrade' || c.type==='sponsor') && c.choices && (c.chosen==null));
  if (nextVar){
    if (p.isAI){
      // Conservative AI choice (prefer not to overspeed a nearby corner)
      const N = G.track.spacesCount;
      const corners = (G.track.corners||[]).slice().sort((a,b)=>a.cornerLineIndex-b.cornerLineIndex);
      let nextCorner = null;
      let bestDist = 999999;
      for (const cn of corners){
        const d = (cn.cornerLineIndex - p.pos.idx + N) % N;
        if (d===0) continue;
        if (d < bestDist){ bestDist = d; nextCorner = cn; }
      }
      const choices = nextVar.choices.slice().sort((a,b)=>a-b);
      if (!nextCorner){
        nextVar.chosen = choices[choices.length-1];
      } else {
        const adj = cornerAdjustments(nextCorner.cornerLineIndex);
        const effLimit = (nextCorner.speedLimit||0) + (adj.limitMod||0) + (p._turnLimitMod||0);
        const high = choices[choices.length-1];
        const low = choices[0];
        const overspeedHigh = (subtotal + high) > effLimit;
        nextVar.chosen = (bestDist <= 6 && overspeedHigh) ? low : high;
      }
    } else {
      G.pendingChoice = {
        kind:'brake',
        pid: p.id,
        cardId: nextVar.id,
        choices: nextVar.choices.slice(),
        baseSpeed: subtotal,
        label: (nextVar.name || nextVar.label || `Upgrade ${nextVar.upgNum||''}`).trim()
      };
      log(`${p.name} must choose a Speed value for ${G.pendingChoice.label} (current subtotal ${subtotal}).`);
      return { nextStep: STEP.REVEAL_MOVE, pause:true };
    }
  }

  if (p._movedThisReveal){
    return { nextStep: STEP.ADRENALINE };
  }

  const speed = p.play.reduce((sum,c)=>{
    if (c.type === 'stress') return sum + (c.revealedCard ? (c.revealedCard.value||0) : 0);
    if (c.type === 'upgrade' || c.type === 'sponsor'){
      const base = (c.choices ? (c.chosen||0) : (c.value||0));
      const plus = (c.plusCards||[]).reduce((s,x)=>s+(x.value||0),0);
      return sum + base + plus;
    }
    return sum + (c.value||0);
  }, 0);
  G.speedForCorner = speed;

  const res = moveExact(p, speed, {countCorners:true, allowFinishCross:true, forbidCrossFinish:false});
  G.cornerCrossed = res.cornerCrossed;
  G.crossedFinishFinal = res.crossedFinishFinal;

  log(`${p.name} reveals ${p.play.map(fmtCard).join(', ')} → Speed ${speed}. Moves to Space ${p.pos.idx}${p.pos.lane===0?" (RL)":" (OUT)"}.`);

  if (G.crossedFinishFinal){
    p.finished = true;
    if (!G.finishedOrder.includes(p.id)) G.finishedOrder.push(p.id);
    p.finishRank = G.finishedOrder.length;
    log(`${p.name} crosses the finish line (final lap)!`);
  }

  // Determine adrenaline eligibility
  G.adrenaline.eligible = (G._adrenalineEligibleIds || []).includes(p.id);
  G.adrenaline.move = false;
  G.adrenaline.cooldownBonus = 0;

  // Prepare pending flags
  G._reactPending = true;
  G._slipPending = true;
  G._discardPending = true;

  p._movedThisReveal = true;
}

  function doAdrenaline(p){
    if (!G.adrenaline.eligible){
      log(`${p.name} is not eligible for Adrenaline.`);
      return;
    }
    // Choice is made in UI; if AI, decide. We read G.adrenaline.move/cooldownBonus set by UI.
    if (p.isAI){
      // Conservative: take cooldown bonus if hand has heat; take +1 move only if safe relative to next corner.
      const heatInHand = p.hand.some(c=>c.type==='heat');
      G.adrenaline.cooldownBonus = heatInHand ? 1 : 0;
      G.adrenaline.move = aiWantsAdrenalineMove(p);
    }

    if (G.adrenaline.move){
      // Move 1 extra space and add +1 to speed for corner check.
      const res = moveExact(p, 1, {countCorners:true, allowFinishCross:true, forbidCrossFinish:false});
      G.cornerCrossed.push(...res.cornerCrossed);
      if (res.crossedFinishFinal){
        G.crossedFinishFinal = true;
        p.finished = true;
        if (!G.finishedOrder.includes(p.id)) G.finishedOrder.push(p.id);
        p.finishRank = G.finishedOrder.length;
      }
      G.speedForCorner += 1;
      log(`${p.name} uses Adrenaline: +1 speed, +1 move.`);
    }

    if (G.adrenaline.cooldownBonus){
      log(`${p.name} uses Adrenaline: +1 Cooldown.`);
    }
  }

  function cooldownCapacity(p){
  let cap = 0;
  if (p.gear === 1) cap += 3;
  if (p.gear === 2) cap += 1;
  cap += (G.adrenaline.cooldownBonus||0);

  // Weather/Road sector modifiers
  const se = sectorEffectsForPlayer(p, 'react');
  if (se.noCooling) return 0;
  cap += (se.cooldownBonus||0);

  return cap;
}

  function doCooldown(p, n, capOverride=null){
  const cap = (capOverride==null) ? cooldownCapacity(p) : capOverride;
  n = clamp(n, 0, cap);
  let moved = 0;
  for (let i=p.hand.length-1; i>=0 && moved<n; i--){
    const c = p.hand[i];
    if (c.type === 'heat'){
      p.hand.splice(i,1);
      p.engine.unshift(c);
      moved++;
    }
  }
  if (moved) log(`${p.name} cools down: returns ${moved} Heat from hand to engine.`);
  return moved;
}

  function doBoost(p){
    if (p.boostUsed) return {ok:false, reason:"Boost already used."};

    const se = sectorEffectsForPlayer(p, 'boost');
    const free = !!se.boostFree;

    if (!free){
      if (p.engine.length <= 0) return {ok:false, reason:"No Heat in engine to pay for Boost."};
      // Pay 1 heat
      payHeat(p, 1);
    } else {
      // Heat Control sector: no heat cost to boost
      log(`${p.name} boosts in Heat Control sector (no Heat paid).`);
    }

    // Flip until basic
    const basic = resolveStressIntoBasic(p);
    if (!basic) return {ok:false, reason:"No cards to flip."};
    // Add to play area
    p.play.push(basic);
    const v = basic.value;
    G.speedForCorner += v;

    // Move accordingly (boost movement)
    const res = moveExact(p, v, {countCorners:true, allowFinishCross:true, forbidCrossFinish:false});
    G.cornerCrossed.push(...res.cornerCrossed);
    if (res.crossedFinishFinal){
      G.crossedFinishFinal = true;
      p.finished = true;
      if (!G.finishedOrder.includes(p.id)) G.finishedOrder.push(p.id);
      p.finishRank = G.finishedOrder.length;
    }
    p.boostUsed = true;
    log(`${p.name} BOOSTS (+): flips Basic ${v} → moves ${v} and increases corner-speed.`);
    return {ok:true};
  }

  function endReact(p){
  // After react is done
  G._reactPending = false;
}

function buildReactActions(p){
  const actions = [];
  for (const c of p.play){
    if (!c || (c.type !== 'upgrade' && c.type !== 'sponsor')) continue;
    const label = (c.name || c.label || `Upgrade ${c.upgNum||''}`).trim();
    // Mandatory-like effects (we still click through to keep ordering clear)
    if (c.scrap && c.scrap > 0){
      actions.push({cardId:c.id, cardLabel:label, type:'scrap', val:c.scrap, mandatory:true});
    }
    // Optional effects
    if (c.cool && c.cool > 0){
      actions.push({cardId:c.id, cardLabel:label, type:'upgCooldown', val:c.cool, mandatory:false});
    }
    if (c.reduceStress && c.reduceStress > 0){
      actions.push({cardId:c.id, cardLabel:label, type:'reduceStress', val:c.reduceStress, mandatory:false});
    }
    if (c.salvage && c.salvage > 0){
      actions.push({cardId:c.id, cardLabel:label, type:'salvage', val:c.salvage, mandatory:false});
    }
    if (c.limitMod && c.limitMod !== 0){
      actions.push({cardId:c.id, cardLabel:label, type:'limitMod', val:c.limitMod, mandatory:false});
    }
    if (c.slipBonus && c.slipBonus > 0){
      actions.push({cardId:c.id, cardLabel:label, type:'slipBonus', val:c.slipBonus, mandatory:false});
    }
    if (c.refresh){
      actions.push({cardId:c.id, cardLabel:label, type:'refresh', val:1, mandatory:false});
    }
    if (c.accelerate){
      actions.push({cardId:c.id, cardLabel:label, type:'accelerate', val:1, mandatory:false});
    }
    // NOTE: Direct Play is not fully supported in this simulator yet.
  }
  p._reactActions = actions;
  p._reactActionIdx = 0;
}

function currentReactAction(p){
  if (!p._reactActions) return null;
  return p._reactActions[p._reactActionIdx] || null;
}

function advanceReactAction(p){
  p._reactActionIdx = (p._reactActionIdx||0) + 1;
}

function hasPendingReactActions(p){
  return !!currentReactAction(p);
}

function resolveScrap(p, n){
  n = Math.max(0, n|0);
  let done = 0;
  for (let i=0;i<n;i++){
    const c = drawFromDeck(p, {allowReshuffle:true});
    if (!c) break;
    p.discard.push(c);
    done++;
  }
  if (done) log(`${p.name} scraps ${done} card(s) from top of deck.`);
  return done;
}

function resolveReduceStress(p, n){
  n = Math.max(0, n|0);
  let done = 0;
  for (let i=p.hand.length-1; i>=0 && done<n; i--){
    const c = p.hand[i];
    if (c.type === 'stress'){
      p.hand.splice(i,1);
      p.discard.push(c);
      done++;
    }
  }
  if (done) log(`${p.name} discards ${done} Stress card(s) (reduce stress).`);
  return done;
}

function resolveSalvage(p, cardIds){
  const ids = new Set(cardIds||[]);
  const picked = [];
  const rest = [];
  for (const c of p.discard){
    if (ids.has(c.id)) picked.push(c);
    else rest.push(c);
  }
  p.discard = rest;
  if (picked.length){
    // Shuffle picked into draw deck
    for (const c of picked) p.deck.push(c);
    shuffleInPlace(p.deck, G.rng);
    log(`${p.name} salvages ${picked.length} card(s) into the draw deck.`);
  } else {
    log(`${p.name} salvages nothing.`);
  }
  return picked.length;
}

function countBaseSymbolsUsed(p){
  const stressSymbols = p.play.filter(c=>c.type==='stress').length;
  const plusSymbols = p._plusSymbolsResolved || 0;
  const boostSymbol = p.boostUsed ? 1 : 0;
  return stressSymbols + plusSymbols + boostSymbol;
}

function applyAccelerate(p){
  // Optional: increase Speed by 1 for every symbol used by you this turn.
  // Approximation: stress symbols + upgrade "+" symbols + boost symbol + applied upgrade symbols + this accelerate symbol.
  const totalSymbols = countBaseSymbolsUsed(p) + (p._symbolsAppliedCount||0) + 1;
  const extra = totalSymbols;
  if (extra <= 0) return 0;

  const res = moveExact(p, extra, {countCorners:true, allowFinishCross:true, forbidCrossFinish:false});
  if (res && res.cornerCrossed && res.cornerCrossed.length){
    G.cornerCrossed.push(...res.cornerCrossed);
  }
  if (res.crossedFinishFinal){
    G.crossedFinishFinal = true;
    p.finished = true;
    if (!G.finishedOrder.includes(p.id)) G.finishedOrder.push(p.id);
    p.finishRank = G.finishedOrder.length;
  }
  G.speedForCorner += extra;
  log(`${p.name} accelerates: +${extra} speed (symbols used: ${totalSymbols}).`);
  return extra;
}

function autoResolveUpgradeActionsAI(p){
  if (!p._reactActions) buildReactActions(p);
  while (hasPendingReactActions(p)){
    const a = currentReactAction(p);
    const c = p.play.find(x=>x && x.id===a.cardId);
    switch(a.type){
      case 'scrap': {
        resolveScrap(p, a.val);
        p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
        break;
      }
      case 'upgCooldown': {
        // Use max
        const moved = doCooldown(p, a.val, a.val);
        if (moved>0) p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
        break;
      }
      case 'reduceStress': {
        const moved = resolveReduceStress(p, a.val);
        if (moved>0) p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
        break;
      }
      case 'salvage': {
        // Take up to N highest value basic/upgrade from discard
        const pick = p.discard.slice().sort((x,y)=>(y.value||0)-(x.value||0)).slice(0, a.val).map(x=>x.id);
        const moved = resolveSalvage(p, pick);
        if (moved>0) p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
        break;
      }
      case 'limitMod': {
        // Apply only if crossed corners
        if ((G.cornerCrossed||[]).length){
          p._turnLimitMod = (p._turnLimitMod||0) + a.val;
          p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
          log(`${p.name} applies ${a.cardLabel}: corner limit ${a.val>0?'+':'−'}${Math.abs(a.val)} this turn.`);
        }
        break;
      }
      case 'slipBonus': {
        p._turnSlipBonus = (p._turnSlipBonus||0) + a.val;
        p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
        log(`${p.name} applies ${a.cardLabel}: Slipstream +${a.val} this turn.`);
        break;
      }
      case 'refresh': {
        if (c){ c._refreshChosen = true; }
        p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
        log(`${p.name} sets ${a.cardLabel} to refresh (topdeck) at Replenish.`);
        break;
      }
      case 'accelerate': {
        // Conservative: only accelerate if no corner crossed (to avoid extra heat), or if plenty of heat
        const nearCorner = (G.cornerCrossed||[]).length>0;
        if (!nearCorner && p.engine.length>=2){
          applyAccelerate(p);
          p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
        }
        break;
      }
    }
    advanceReactAction(p);
  }
}

  function slipEligible(p){
    if (G.crossedFinishFinal) return false;
    // Eligible if you land next to another car (same space other lane) OR in a space behind a car/cars (i.e., any car in the next space ahead).
    const same = occupiedAt(p.pos.idx).some(x => x && x.id !== p.id);
    const ahead = occupiedAt(stepForward(p.pos.idx)).some(x => x);
    return same || ahead;
  }

  function doSlipstream(p, doIt){
  if (!doIt) {
    log(`${p.name} skips Slipstream.`);
    return;
  }

  const se = sectorEffectsForPlayer(p, 'slip');
  if (se.noSlip){
    log(`${p.name} cannot start Slipstream in this sector (No Slipstream).`);
    return;
  }

  if (!slipEligible(p)){
    log(`${p.name} cannot Slipstream.`);
    return;
  }

  const upgBonus = (p._turnSlipBonus||0);
  const dist = 2 + (se.slipBonus||0) + upgBonus;

  const res = moveExact(p, dist, {countCorners:true, allowFinishCross:true, forbidCrossFinish:true});
  if (res && res.cornerCrossed && res.cornerCrossed.length){
    G.cornerCrossed.push(...res.cornerCrossed);
  }
  log(`${p.name} slipstreams +${dist} space(s).`);
  // Championship: press corner reward if slipstream crosses it
  if (G.modules.championship && G.champ){
    for (const cc of (res.cornerCrossed||[])){
      if (isPressCorner(cc.cornerLineIndex)){
        champAwardSponsorToPlayer(p, 'slipstream', cc.cornerLineIndex);
      }
    }
  }
}

  function endSlipstream(p){
    G._slipPending = false;
  }

  function doCheckCorner(p){
  const list = (G.cornerCrossed||[]);
  if (!list.length){
    log(`${p.name} crosses no corners.`);
    return;
  }

  for (const corner of list){
    const baseLimit = corner.speedLimit;
    const speed = G.speedForCorner;

    const adj = cornerAdjustments(corner.cornerLineIndex);
    const upgMod = (p._turnLimitMod||0);
    const limit = baseLimit + (adj.limitMod||0) + upgMod;

    if (speed <= limit){
      const mods=[];
      if (adj.limitMod) mods.push(`road ${adj.limitMod>0?'+':'−'}${Math.abs(adj.limitMod)}`);
      if (upgMod) mods.push(`upgrade ${upgMod>0?'+':'−'}${Math.abs(upgMod)}`);
      const modTxt = mods.length ? ` (limit ${baseLimit} + ${mods.join(' + ')} = ${limit})` : '';
      log(`${p.name} corner @${corner.cornerLineIndex}${modTxt}: Speed ${speed} ≤ ${limit}. OK.`);
      continue;
    }

    let need = speed - limit;
    if (adj.overheat) need += 1;

    const paid = payHeat(p, need);
    if (paid === need){
      const extra = adj.overheat ? ' (+1 Overheat)' : '';
      const mods=[];
      if (adj.limitMod) mods.push(`road ${adj.limitMod>0?'+':'−'}${Math.abs(adj.limitMod)}`);
      if (upgMod) mods.push(`upgrade ${upgMod>0?'+':'−'}${Math.abs(upgMod)}`);
      const modTxt = mods.length ? ` (limit ${baseLimit} + ${mods.join(' + ')} = ${limit})` : '';
      log(`${p.name} corner @${corner.cornerLineIndex}${modTxt}: Speed ${speed} > ${limit}. Pays ${need} Heat${extra}.`);
      continue;
    }

    log(`${p.name} corner @${corner.cornerLineIndex}: needed ${need} Heat but paid only ${paid} → SPIN OUT!`);

    const N = G.track.spacesCount;
    const before = (corner.cornerLineIndex - 1 + N) % N;

    let placed = findBestSpot(before);
    if (!placed){
      for (let back=1; back<=N; back++){
        const j = (before - back + N) % N;
        placed = findBestSpot(j);
        if (placed) break;
      }
    }

    p.pos.idx = placed.idx;
    p.pos.lane = placed.lane;

    const add = (p.gear <= 2) ? 1 : 2;
    addStressToHand(p, add);
    p.gear = 1;
    log(`${p.name} spins out → back to Space ${p.pos.idx}. Takes ${add} Stress into hand. Gear → 1.`);
    break;
  }
}

  function doReplenish(p){
  if (p.play.length){
    const toDiscard = [];
    const toRefresh = [];
    while (p.play.length){
      const c = p.play.shift();
      if (c.type === 'stress' && c.revealedCard){
        toDiscard.push(c.revealedCard);
        delete c.revealedCard;
      }
      if (c.type === 'upgrade' && c._refreshChosen){
        toRefresh.push(c);
        c._refreshChosen = false;
      } else {
        toDiscard.push(c);
      }
    }
    discardCards(p, toDiscard);
    if (toRefresh.length){
      const nRef = toRefresh.length;
      // Put refresh cards on top in the order they were resolved (last chosen ends up on top).
      while (toRefresh.length){
        const c = toRefresh.pop();
        p.deck.unshift(c);
      }
      log(`${p.name} refreshes ${nRef} card(s) to top of deck.`);
    }
  }

  // Clear per-turn state
  p._revealPrepared = false;
  p._revealProcessed = false;
  p._movedThisReveal = false;
  p._turnSlipBonus = 0;
  p._turnLimitMod = 0;
  p._symbolsAppliedCount = 0;
  p._reactActions = null;
  p._reactActionIdx = 0;

  // Draw back up to 7
  const before = p.hand.length;
  while (p.hand.length < 7){
    const c = drawFromDeck(p, {allowReshuffle:true});
    if (!c) break;
    p.hand.push(c);
  }
  // Mark this car as fully resolved for this round (prevents round-skip or infinite rebuild loops)
  p._resolvedThisRound = true;
  log(`${p.name} replenishes to ${p.hand.length} card(s). Deck ${p.deck.length}, Discard ${p.discard.length}, Engine Heat ${p.engine.length}.`);
}

  /***********************
   * Discard UI action
   ***********************/
  function confirmDiscard(p, selectedIds){
    // Can discard any number except heat/stress.
    const ids = new Set(selectedIds);
    const toDisc = [];
    const keep = [];
    for (const c of p.hand){
      if (ids.has(c.id)){
        if (isNonDiscardable(c)){
          keep.push(c);
        } else {
          toDisc.push(c);
        }
      } else keep.push(c);
    }
    p.hand = keep;
    if (toDisc.length){
      discardCards(p, toDisc);
      log(`${p.name} discards ${toDisc.map(fmtCard).join(', ')}.`);
    } else {
      log(`${p.name} discards nothing.`);
    }

    // Discard is step 8; after confirming (or skipping) we must advance to step 9.
    G._discardPending = false;
    if (G.phase === PHASE.RESOLUTION && G.activeStep === STEP.DISCARD){
      G.activeStep = STEP.REPLENISH;
    }
    renderAll();
  }

  /***********************
   * AI
   ***********************/
  function nearestCornerAheadFrom(idx, maxSteps){
    const N = G.track.spacesCount;
    for (let s=1; s<=maxSteps; s++){
      const j = (idx + s) % N;
      const corner = crossesCornerOnEnter(j);
      if (corner) return {corner, steps:s};
      // If we'd hit finish on final lap, corners after finish are ignored; AI simplification ignores that.
    }
    return null;
  }

  function aiWantsAdrenalineMove(p){
    // If +1 move likely helps without causing corner risk beyond engine heat.
    const probe = nearestCornerAheadFrom(p.pos.idx, 10);
    if (!probe) return true;
    const limit = probe.corner.speedLimit;
    const speed = G.speedForCorner + 1;
    const need = Math.max(0, speed - limit);
    return need <= p.engine.length;
  }

  function aiPlan(p){
    // Conservative planning:
    // 1) If hand has lots of Heat, go low gear to cooldown.
    const heatInHand = p.hand.filter(c=>c.type==='heat').length;
    const playable = p.hand.filter(cardCanBePlayed);
    // Choose gear
    let desiredGear = p.gear;
    if (heatInHand >= 3) desiredGear = 1;
    else if (heatInHand === 2) desiredGear = 2;
    else desiredGear = clamp(p.gear + 1, 1, 4);

    // Avoid shifting 2 unless enough heat
    let delta = desiredGear - p.gear;
    if (Math.abs(delta) === 2 && p.engine.length <= 0){
      desiredGear = p.gear + Math.sign(delta); // shift 1 instead
    }

    // Apply shift
    applyShift(p, desiredGear);

    // Select cards to play: try to keep speed near corner limit
    const needCards = p.gear;
    const handPlayable = p.hand.filter(cardCanBePlayed);

    // Determine a safe speed target based on nearest corner within ~12 spaces
    const probe = nearestCornerAheadFrom(p.pos.idx, 12);
    let targetSpeed = 8;
    if (probe){
      targetSpeed = probe.corner.speedLimit + Math.min(1, p.engine.length); // allow slight overspeed
    } else {
      targetSpeed = 10;
    }

    // Build best subset of size needCards to get close to targetSpeed, avoid stress if possible.
    const candidates = handPlayable.slice();
    // Sort by preferring non-stress
    candidates.sort((a,b)=>{
      const sa = (a.type==='stress') ? 1 : 0;
      const sb = (b.type==='stress') ? 1 : 0;
      if (sa !== sb) return sa - sb;
      return (b.value||0) - (a.value||0);
    });

    // Simple greedy: pick high cards then adjust
    let picked=[];
    for (const c of candidates){
      if (picked.length>=needCards) break;
      picked.push(c);
    }

    // Try small swaps to get closer to target
    function sum(arr){ return arr.reduce((s,c)=>s+(c.value||0),0); }
    let best = picked.slice();
    let bestDiff = Math.abs(sum(best)-targetSpeed) + best.filter(c=>c.type==='stress').length*1.5;

    // brute small search if candidates not too many
    const pool = candidates.slice(0, Math.min(10, candidates.length));
    const n=pool.length;
    if (n>=needCards && needCards<=4){
      // enumerate combinations
      const idxs = Array.from({length:needCards}, (_,i)=>i);
      function evalCombo(idxs){
        const combo = idxs.map(i=>pool[i]);
        const diff = Math.abs(sum(combo)-targetSpeed) + combo.filter(c=>c.type==='stress').length*1.5;
        if (diff < bestDiff){ bestDiff=diff; best=combo; }
      }
      // generate combinations
      function comb(start, depth, acc){
        if (acc.length===needCards){ evalCombo(acc); return; }
        for (let i=start;i<n;i++) comb(i+1, depth+1, acc.concat(i));
      }
      comb(0,0,[]);
    }

    p.planned.cards = best.map(c=>c.id);
  }

  function autoResolveAIIfNeeded(){
    if (G.phase !== PHASE.RESOLUTION) return;
    const p = activePlayer();
    if (!p || !p.isAI || p.removedFromTrack) return;

    // If we are at adrenaline step, decide now.
    if (G.activeStep === STEP.ADRENALINE){
      doAdrenaline(p);
      G.activeStep = STEP.REACT;
    }

    // React: do cooldown and maybe boost
    if (G.activeStep === STEP.REACT){
      // Resolve any upgrade symbols sequentially (AI auto-resolves).
      autoResolveUpgradeActionsAI(p);

      const cap = cooldownCapacity(p);
      if (cap > 0){
        // move as many heat from hand as possible
        doCooldown(p, cap);
      }
      // Boost? Only if it won't likely cause spin out (conservative).
      const probe = nearestCornerAheadFrom(p.pos.idx, 10);
      const predicted = G.speedForCorner;
      let effLimit = 99;
      let heatNeed = 0;
      if (probe){
        const adj = cornerAdjustments(probe.corner.cornerLineIndex);
        effLimit = probe.corner.speedLimit + (adj.limitMod||0);
        heatNeed = Math.max(0, predicted - effLimit) + ((adj.overheat && predicted>effLimit)?1:0);
      }
      // Boost increases speed; conservative: only boost if far from any corner soon
      const safe = !probe || probe.steps > 6;

      const se = sectorEffectsForPlayer(p, 'boost');
      const canPay = se.boostFree ? true : (p.engine.length >= (heatNeed + 1));
      if (!p.boostUsed && canPay && safe){
        doBoost(p);
      }

      G._reactPending = false;
      G.activeStep = STEP.SLIPSTREAM;
    }

    if (G.activeStep === STEP.SLIPSTREAM){
      const can = slipEligible(p);
      if (can){
        const se = sectorEffectsForPlayer(p, 'slip');
        // Conservative: slipstream if it doesn't approach a corner too soon and sector allows starting it.
        const probe = nearestCornerAheadFrom(p.pos.idx, 6);
        const doIt = (!probe) && !se.noSlip;
        doSlipstream(p, doIt);
      }
      G._slipPending = false;
      G.activeStep = STEP.CHECK_CORNER;
    }

    if (G.activeStep === STEP.CHECK_CORNER){
      doCheckCorner(p);
      G.activeStep = STEP.DISCARD;
    }

    if (G.activeStep === STEP.DISCARD){
      // Discard non-essential non-stress/heat, keep high cards
      const disc=[];
      for (const c of p.hand){
        if (isNonDiscardable(c)) continue;
        if (c.type==='basic' && c.value>=3) continue;
        if (c.type==='upgrade' && c.value>=5) continue;
        // discard low stuff
        disc.push(c.id);
      }
      confirmDiscard(p, disc);
      G.activeStep = STEP.REPLENISH;
    }

    if (G.activeStep === STEP.REPLENISH){
      doReplenish(p);
      // Immediately advance to next car after replenishing.
      advanceResolutionIdx();
      return;
    }

    if (G.activeStep === STEP.DONE){
      advanceResolutionIdx();
    }

    renderAll();
  }

  /***********************
   * Rendering
   ***********************/
  function updateSeedPill(){
    $('#seedPill').textContent = `Seed: ${G.seed}`;
  }

  function updatePhasePill(){
    const map={setup:"Setup",draft:"Garage Draft",planning:"Planning",resolution:"Resolution",finished:"Finished"};
    $('#phasePill').textContent = `Phase: ${map[G.phase]||G.phase}`;
  }

  function updateUndoBtn(){
    $('#btnUndo').disabled = history.length === 0;
    $('#btnUndo').textContent = history.length ? `Undo (${history.length})` : 'Undo';
  }

  function renderTrack(){
    const grid = $('#trackGrid');
    const t = G.track;
    document.documentElement.style.setProperty('--spaceW', $('#zoom').value + 'px');

    grid.innerHTML = '';
    // Weather/Road summary banner
    const tokEl = $('#trackTokens');
    if (tokEl){
      if (G.weatherRoad){
        tokEl.style.display = '';
        const w = G.weatherRoad.weatherToken;
        const corners = (G.track.corners||[]).slice().sort((a,b)=>a.cornerLineIndex-b.cornerLineIndex);
        const sectorEntries = corners.map(c=>{
          const st = (G.weatherRoad.roadSector||{})[c.cornerLineIndex];
          if (!st) return null;
          let lbl = st.label;
          if (st.key === 'weather' && G.weatherRoad.weatherToken && G.weatherRoad.weatherToken.sectorLabel){
            lbl = `${st.label} → ${G.weatherRoad.weatherToken.sectorLabel}`;
          }
          return `After corner @${c.cornerLineIndex}: ${lbl}`;
        }).filter(Boolean);
        const sectorLines = sectorEntries.join('<br>');
        const cornerEntries = corners.map(c=>{
          const rt = (G.weatherRoad.roadCorner||{})[c.cornerLineIndex];
          if (!rt) return null;
          return `Corner @${c.cornerLineIndex}: ${rt.label}`;
        }).filter(Boolean);
        const cornerLines = cornerEntries.join('<br>');
        const pressHtml = (G.modules.championship && G.champ && (G.champ.pressCorners||[]).length) ? (() => {
          const pcs = (G.champ.pressCorners||[]).slice().sort((a,b)=>a-b);
          const list = pcs.map(x=>`@${x}`).join(', ');
          const detail = 'Earn Sponsorship if you Slipstream across a PRESS corner line, or overspeed that corner by 2+ (after modifiers), and you did not spin out.';
          return `
            <div style="flex:1">
              <div class="small muted">Press corners</div>
              <div class="tokLine"><span class="badge press">PRESS</span> ${escapeHtml(list)}</div>
              <div class="small muted" style="margin-top:4px">${escapeHtml(detail)}</div>
            </div>`;
        })() : '';

        tokEl.innerHTML = `
          <div class="row" style="gap:18px">
            <div style="min-width:170px">
              <div class="small muted">Weather</div>
              <div class="tokLine"><span class="pill">${escapeHtml(w.label)}</span> ${escapeHtml(w.desc||'')}</div>
            </div>
            <div style="flex:1">
              <div class="small muted">Sector effects</div>
              <div class="tokLine">${sectorLines||'(none)'}</div>
            </div>
            <div style="flex:1">
              <div class="small muted">Corner tokens</div>
              <div class="tokLine">${cornerLines||'(none)'}</div>
            </div>
            ${pressHtml}
          </div>
        `;
      } else {
        tokEl.style.display = 'none';
        tokEl.innerHTML = '';
      }
    }

    for (let i=0;i<t.spacesCount;i++){
      const space = document.createElement('div');
      space.className = 'space';
      const corner = (t.corners||[]).find(c=>c.cornerLineIndex===i);
      const badges = [];
      if (i === t.finishIndex) badges.push(`<span class="badge finish">FINISH</span>`);
      if (corner) badges.push(`<span class="badge corner">CORNER ≤${corner.speedLimit}</span>`);
      if (G.modules.championship && isPressCorner(i)) badges.push(`<span class="badge press">PRESS</span>`);
      if (G.weatherRoad){
        const rt = (G.weatherRoad.roadCorner||{})[i];
        if (rt) badges.push(`<span class="badge road">${escapeHtml(rt.label)}</span>`);
        // also show if THIS corner has a sector token assigned (token applies to sector after this corner)
        const stHere = (G.weatherRoad.roadSector||{})[i];
        if (stHere){
          badges.push(`<span class="badge sector">Sector: ${escapeHtml(stHere.label)}</span>`);
          if (stHere.key === 'weather' && G.weatherRoad.weatherToken && G.weatherRoad.weatherToken.sectorLabel){
            badges.push(`<span class="badge sector">${escapeHtml(G.weatherRoad.weatherToken.sectorLabel)}</span>`);
          }
        }
        // show sector token at the first space after a corner line
        const srcCorner = (t.corners||[]).find(c=>stepForward(c.cornerLineIndex)===i);
        if (srcCorner){
          const st = (G.weatherRoad.roadSector||{})[srcCorner.cornerLineIndex];
          if (st){
            badges.push(`<span class="badge sector">${escapeHtml(st.label)}</span>`);
            if (st.key === 'weather' && G.weatherRoad.weatherToken && G.weatherRoad.weatherToken.sectorLabel){
              badges.push(`<span class="badge sector">${escapeHtml(G.weatherRoad.weatherToken.sectorLabel)}</span>`);
            }
          }
        }
      }

      space.innerHTML = `
        <div class="idx">
          <span>#${i}</span>
          <span style="display:flex;flex-direction:column;gap:2px;align-items:flex-end;max-width:78%">${badges.join('')}</span>
        </div>
        <div class="spots ${t.spotsPerSpace===1?'one':''}">
          <div class="spot raceline" data-idx="${i}" data-lane="0"></div>
          ${t.spotsPerSpace===2?`<div class="spot" data-idx="${i}" data-lane="1"></div>`:''}
        </div>
      `;
      grid.appendChild(space);
    }

    // place cars
    for (const p of G.players){
      if (p.removedFromTrack) continue; // cars stay on track until end of round even if they finish.
      const spot = $(`.spot[data-idx="${p.pos.idx}"][data-lane="${p.pos.lane}"]`, grid);
      if (!spot) continue;
      spot.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'carWrap';
      const token = document.createElement('div');
      token.className = 'car' + (p.isAI ? ' ai' : '');
      token.style.background = p.color;
      token.textContent = p.name.slice(0,1).toUpperCase();
      if (p.finished){
        token.style.outline = '2px solid rgba(125,255,155,.7)';
        token.style.opacity = '0.85';
      }
      token.title = `${p.name} (Gear ${p.gear}) Space ${p.pos.idx} Lane ${p.pos.lane===0?'Race Line':'Outside'} Lap ${p.lap}/${G.track.lapsRequired}`;
      wrap.appendChild(token);
      spot.appendChild(wrap);
    }
  
    renderTrackMap();
  }
  function renderTrackMap(){
    const mode = ($('#trackViewMode')?.value) || 'map';
    const canvas = $('#trackCanvas');
    const grid = $('#trackGrid');
    if (!canvas) return;
    if (mode !== 'map'){
      canvas.style.display = 'none';
      if (grid) grid.style.display = '';
      return;
    }
    canvas.style.display = '';
    if (grid) grid.style.display = 'none';

    const t = G.track;
    const ctx = canvas.getContext('2d');
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const W = canvas.clientWidth || 900;
    const H = canvas.clientHeight || 520;
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,W,H);


    // Optional background image (local upload). Not included in the HTML.
    const bg = getTrackBg();
    if (bg && bg.dataUrl){
      const k = trackKey();
      let img = bgImgCache.get(k);
      if (!img){
        img = new Image();
        img.onload = () => { bgImgCache.set(k, img); renderTrackMap(); };
        img.onerror = () => { /* ignore */ };
        img.src = bg.dataUrl;
      } else {
        // Match canvas height to background aspect ratio for nicer alignment
        const desiredH = Math.max(200, Math.round(W * (img.naturalHeight / img.naturalWidth)));
        if (Math.abs((canvas.clientHeight||H) - desiredH) > 2){
          canvas.style.height = desiredH + 'px';
        }
        const opacity = (bg.opacity ?? 0.85);
        const scale = (bg.scale ?? 1.0);
        const dx = (bg.dx ?? 0) * W;
        const dy = (bg.dy ?? 0) * H;
        const drawW = W * scale;
        const drawH = (W * (img.naturalHeight / img.naturalWidth)) * scale;
        ctx.save();
        ctx.globalAlpha = opacity;
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(img, dx, dy, drawW, drawH);
        ctx.restore();
      }
    }

    // ---- Layout: Map View polyline (original, schematic) ----
    const poly = (Array.isArray(t.mapPoly) && t.mapPoly.length>=4) ? t.mapPoly : (DEFAULT_TRACK.mapPoly || [
      [0.14,0.80],[0.82,0.80],[0.92,0.72],[0.92,0.22],[0.72,0.18],[0.54,0.26],
      [0.58,0.52],[0.44,0.62],[0.30,0.52],[0.36,0.34],[0.24,0.22],[0.12,0.30],[0.10,0.52],[0.14,0.80]
    ]);
    const N = t.spacesCount;

    function dist(a,b){ const dx=a[0]-b[0], dy=a[1]-b[1]; return Math.hypot(dx,dy); }
    const pts = poly.map(p=>[p[0]*W, p[1]*H]);
    const segLen = [];
    let total = 0;
    for (let i=0;i<pts.length-1;i++){
      const d = dist(pts[i], pts[i+1]);
      segLen.push(d); total += d;
    }
    // sample positions along polyline
    const samples = [];
    for (let i=0;i<N;i++){
      const target = (i/(N)) * total;
      let acc = 0, seg = 0;
      while (seg < segLen.length && acc + segLen[seg] < target){ acc += segLen[seg]; seg++; }
      const a = pts[Math.min(seg, pts.length-2)];
      const b = pts[Math.min(seg+1, pts.length-1)];
      const local = segLen[seg] ? (target-acc)/segLen[seg] : 0;
      const x = a[0] + (b[0]-a[0])*local;
      const y = a[1] + (b[1]-a[1])*local;
      const tx = (b[0]-a[0]); const ty=(b[1]-a[1]);
      const tl = Math.hypot(tx,ty) || 1;
      const nx = -ty/tl, ny = tx/tl; // normal
      samples.push({x,y, nx, ny, tx:tx/tl, ty:ty/tl});
    }

    // Background vignette
    ctx.save();
    const grd = ctx.createRadialGradient(W*0.7,H*0.6,10,W*0.7,H*0.6,Math.max(W,H)*0.9);
    grd.addColorStop(0,'rgba(0,0,0,0)');
    grd.addColorStop(1,'rgba(0,0,0,0.35)');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    // Draw road as thick stroke along samples
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // road shadow
    ctx.beginPath();
    for (let i=0;i<samples.length;i++){
      const s = samples[i];
      if (i===0) ctx.moveTo(s.x, s.y);
      else ctx.lineTo(s.x, s.y);
    }
    ctx.strokeStyle = 'rgba(0,0,0,0.45)';
    ctx.lineWidth = 52;
    ctx.stroke();

    // asphalt
    ctx.beginPath();
    for (let i=0;i<samples.length;i++){
      const s = samples[i];
      if (i===0) ctx.moveTo(s.x, s.y);
      else ctx.lineTo(s.x, s.y);
    }
    ctx.strokeStyle = '#1b1f26';
    ctx.lineWidth = 46;
    ctx.stroke();

    // lane divider (dashed)
    ctx.beginPath();
    for (let i=0;i<samples.length;i++){
      const s = samples[i];
      if (i===0) ctx.moveTo(s.x, s.y);
      else ctx.lineTo(s.x, s.y);
    }
    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
    ctx.setLineDash([10,12]);
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.setLineDash([]);

    // finish line
    const fini = t.finishIndex ?? 0;
    const fs = samples[(fini+N)%N];
    ctx.save();
    ctx.translate(fs.x, fs.y);
    // rotate to tangent
    const ang = Math.atan2(fs.ty, fs.tx);
    ctx.rotate(ang);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillRect(-18,-22,36,6);
    ctx.fillRect(-18,16,36,6);
    ctx.fillStyle = 'rgba(255,255,255,0.45)';
    for (let i=-16;i<=16;i+=8){
      ctx.fillRect(i,-22,4,44);
    }
    ctx.restore();

    // corner markers + tokens
    const corners = (t.corners||[]).slice().sort((a,b)=>a.cornerLineIndex-b.cornerLineIndex);
    function drawBadge(x,y,txt,kind){
      ctx.save();
      ctx.translate(x,y);
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      const padX=8, padY=5;
      const w = ctx.measureText(txt).width + padX*2;
      const h = 22;
      ctx.fillStyle = kind==='corner' ? 'rgba(255,206,91,0.95)' :
                      kind==='road'   ? 'rgba(91,214,255,0.9)' :
                      kind==='sector' ? 'rgba(125,255,155,0.85)' :
                      kind==='press'  ? 'rgba(255,110,205,0.90)' :
                                       'rgba(255,255,255,0.85)';
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.lineWidth = 1;
      roundRect(ctx, -w/2, -h/2, w, h, 10);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = 'rgba(0,0,0,0.82)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(txt, 0, 0);
      ctx.restore();
    }
    function roundRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    for (const c of corners){
      const idx = (c.cornerLineIndex+N)%N;
      const s = samples[idx];
      // place marker slightly off-road
      const bx = s.x + s.nx*40;
      const by = s.y + s.ny*40;
      drawBadge(bx,by,`≤${c.speedLimit} @${c.cornerLineIndex}`,'corner');

      if (G.modules.championship && isPressCorner(c.cornerLineIndex)){
        drawBadge(bx,by-26,`PRESS @${c.cornerLineIndex}`,'press');
      }

      if (G.weatherRoad){
        const rt = (G.weatherRoad.roadCorner||{})[c.cornerLineIndex];
        if (rt){
          drawBadge(bx,by+26,rt.label,'road');
        }
        const st = (G.weatherRoad.roadSector||{})[c.cornerLineIndex];
        if (st){
          // sector badge appears near first space after corner
          const s2 = samples[(idx+1)%N];
          const sx = s2.x + s2.nx*40;
          const sy = s2.y + s2.ny*40;
          drawBadge(sx,sy,st.label,'sector');
          if (st.key === 'weather' && G.weatherRoad.weatherToken && G.weatherRoad.weatherToken.sectorLabel){
            drawBadge(sx,sy+26,G.weatherRoad.weatherToken.sectorLabel,'sector');
          }
        }
      }
    }

    // weather badge
    if (G.weatherRoad){
      const w = G.weatherRoad.weatherToken;
      drawBadge(W*0.10,H*0.12,`Weather: ${w.setupLabel} • ${w.sectorLabel}`,'road');
    }

    

    // championship badge
    if (G.modules.championship && G.champ){
      drawBadge(W*0.10,H*0.17,`Championship: Race ${G.champ.raceIndex+1}/${G.champ.racesTotal}`,'press');
    }
// Draw cars
    for (const p of G.players){
      if (p.removedFromTrack) continue;
      const idx = (p.pos.idx+N)%N;
      const s = samples[idx];
      const laneOffset = (p.pos.lane===0 ? -9 : 9);
      const x = s.x + s.nx*laneOffset;
      const y = s.y + s.ny*laneOffset;
      // token shadow
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.arc(x+2,y+3,10,0,Math.PI*2);
      ctx.fill();
      // token body
      ctx.beginPath();
      ctx.fillStyle = p.color || '#ffffff';
      ctx.arc(x,y,10,0,Math.PI*2);
      ctx.fill();
      // outline/highlight active
      const isActive = (G.phase===PHASE.RESOLUTION && activePlayer()===p);
      ctx.lineWidth = isActive ? 3 : 2;
      ctx.strokeStyle = isActive ? 'rgba(91,214,255,0.95)' : 'rgba(255,255,255,0.75)';
      ctx.stroke();

      ctx.fillStyle = 'rgba(0,0,0,0.85)';
      ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(p.short || p.name?.slice(0,2) || 'P', x, y);
    }
  }


    // Map path editor overlay (visual control points)
    if (mapEditEnabled){
      const polyN = poly; // normalized points
      ctx.save();
      ctx.lineWidth = 2;
      ctx.setLineDash([6,6]);
      ctx.strokeStyle = 'rgba(91,214,255,0.85)';
      ctx.beginPath();
      for (let i=0;i<polyN.length;i++){
        const px = polyN[i][0]*W, py = polyN[i][1]*H;
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.setLineDash([]);

      for (let i=0;i<polyN.length;i++){
        const px = polyN[i][0]*W, py = polyN[i][1]*H;
        const r = (i===mapDragIndex) ? 7 : 5;
        ctx.beginPath();
        ctx.arc(px,py,r,0,Math.PI*2);
        ctx.fillStyle = (i===mapDragIndex) ? 'rgba(255,206,91,0.95)' : 'rgba(91,214,255,0.95)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.6)';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      // help text
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      ctx.fillRect(10,10,360,44);
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign='left'; ctx.textBaseline='top';
      ctx.fillText('Path Edit: drag points • Shift+Click add • Alt+Click delete • Edit button to exit', 18, 18);
      ctx.restore();
    }

  function renderRight(){
    updatePhasePill();
    updateSeedPill();

    const right = $('#rightPanel');
    const title = $('#rightTitle');
    const turnTag = $('#turnTag');

    if (G.phase === PHASE.SETUP){
      title.textContent = 'Setup';
      turnTag.textContent = '—';
      right.innerHTML = renderSetupUI();
      hookSetupUI();
      return;
    }

    if (G.phase === PHASE.DRAFT){
	      // Two draft modes share the same PHASE.DRAFT:
	      //  - Garage draft (3 picks each)
	      //  - Championship "Build Your Car" (1 pick each)
	      const d = G.draft;
	      const cur = (d && d.currentPlayerId) ? G.players.find(x=>x.id===d.currentPlayerId) : null;
	      turnTag.textContent = cur ? `Picker: ${cur.name}` : 'Draft';
	
	      if (d && d.kind === 'champBuild'){
	        title.textContent = 'Build Your Car';
	        right.innerHTML = renderChampDraftUI();
	        hookChampDraftUI();
	        return;
	      }

	      title.textContent = 'Garage Draft';
	      right.innerHTML = renderDraftUI();
	      hookDraftUI();
	      return;
    }

    if (G.phase === PHASE.PLANNING){
      title.textContent = `Planning (Round ${G.round})`;
      const p = G.players[G.planningIdx];
      turnTag.textContent = p ? `Player: ${p.name}` : '—';
      right.innerHTML = renderPlanningUI(p);
      hookPlanningUI(p);
      return;
    }

    if (G.phase === PHASE.RESOLUTION){
      const p = activePlayer();
      title.textContent = `Resolution (Round ${G.round})`;
      turnTag.textContent = p ? `Active: ${p.name} • Step: ${prettyStep(G.activeStep)}` : '—';
      right.innerHTML = renderResolutionUI(p);
      hookResolutionUI(p);
      return;
    }

    if (G.phase === PHASE.FINISHED){
      title.textContent = 'Finished';
      turnTag.textContent = 'Race over';
      right.innerHTML = renderFinishedUI();
      hookFinishedUI();
      return;
    }
  }

  function prettyStep(step){
    const m={
      reveal_move:"Reveal & Move",
      adrenaline:"Adrenaline",
      react:"React",
      slipstream:"Slipstream",
      check_corner:"Check Corner",
      discard:"Discard",
      replenish:"Replenish",
      done:"Done"
    };
    return m[step]||step;
  }

  function renderSetupUI(){
    const t = G.track;
    const players = G.players;
    const pid = G.trackPresetId || getInitialTrackPresetId();
    const builtIns = (TRACK_LIBRARY||[]).filter(p=>p && p.id && p.id!=='custom');
    const userPresets = loadCustomPresets();
    const selectedUser = userPresets.find(p=>p.id===pid) || null;

    const builtOpt = builtIns.map(p=>`<option value="${p.id}" ${pid===p.id?'selected':''}>${escapeHtml(p.name)}</option>`).join('');
    const userOpt = userPresets.map(p=>`<option value="${p.id}" ${pid===p.id?'selected':''}>${escapeHtml(p.name)}</option>`).join('');

    const trackOptions =
      `<optgroup label="Built-in">${builtOpt}</optgroup>`
      + (userPresets.length ? `<optgroup label="Saved">${userOpt}</optgroup>` : '')
      + `<option value="custom" ${pid==='custom'?'selected':''}>Custom (your edits)</option>`;

    const playerRows = players.map((p, idx) => `
      <div class="note" style="display:flex;flex-direction:column;gap:8px">
        <div class="row" style="justify-content:space-between">
          <strong>${escapeHtml(p.name)}</strong>
          <div class="row">
            <span class="tag2">${p.isAI?'AI':'Human'}</span>
            <button class="btn small danger" data-act="rmPlayer" data-idx="${idx}">Remove</button>
          </div>
        </div>
        <div class="grid3">
          <label class="small">Name<br><input data-act="pName" data-idx="${idx}" value="${escapeHtml(p.name)}" /></label>
          <label class="small">Color<br><input data-act="pColor" data-idx="${idx}" type="color" value="${p.color}" /></label>
          <label class="small">Control<br>
            <select data-act="pAI" data-idx="${idx}">
              <option value="0" ${!p.isAI?'selected':''}>Human</option>
              <option value="1" ${p.isAI?'selected':''}>AI</option>
            </select>
          </label>
        </div>
      </div>
    `).join('');

    return `
      <div class="note">
        <div class="row" style="justify-content:space-between">
          <div>
            <strong>Seeded RNG</strong>
            <div class="small muted">Same seed + same actions → same results.</div>
          </div>
          <div class="row">
            <input id="seedInput" style="width:220px" value="${escapeHtml(G.seed)}" />
            <button class="btn small" data-act="setSeed">Set</button>
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="note">
        <div class="row" style="justify-content:space-between">
          <div>
            <strong>Track Preset</strong>
            <div class="small muted">Pick a preset (schematic) or use Custom. Edit details in Track Editor.</div>
          <div class="row" style="margin-top:8px">
            <label class="small" style="flex:1">Preset
              <select id="trackPresetSel" style="width:100%;margin-top:6px">${trackOptions}</select>
            </label>
          </div>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:10px">
            <label class="small" style="flex:1;min-width:220px">Saved preset name
              <input id="presetNameInput" type="text" style="width:100%;margin-top:6px"
                value="${escapeHtml((selectedUser?.name) || (pid==='custom'?'':(getPresetById(pid)?.name||'')))}"
                placeholder="e.g., USA — My Exact Board" />
            </label>
            <div style="display:flex;gap:8px;align-items:flex-end;flex-wrap:wrap">
              <button class="btn small" data-act="savePresetNew" title="Save the current track as a new preset">Save as new</button>
              <button class="btn small" data-act="savePresetOverwrite" ${selectedUser?'' :'disabled'} title="Overwrite the selected saved preset with current track">Save to preset</button>
              <button class="btn small" data-act="renamePreset" ${selectedUser?'' :'disabled'} title="Rename the selected saved preset">Rename</button>
              <button class="btn danger small" data-act="deletePreset" ${selectedUser?'' :'disabled'} title="Delete the selected saved preset">Delete</button>
            </div>
          </div>
          <div class="small muted" style="margin-top:6px">
            Tip: Pick a saved preset, edit it in Track Editor, then click <b>Save to preset</b>. Built-in presets are read-only; editing them creates a Custom track unless you save as a new preset.
          </div>

          </div>
          <div class="row">
            <button class="btn small" data-act="resetTrack">Reset to default</button>
          </div>
        </div>
        <div class="grid3" style="margin-top:8px">
          <label class="small">Spaces<br><input id="trkSpaces" type="number" min="10" max="200" value="${t.spacesCount}" /></label>
          <label class="small">Spots/Space<br>
            <select id="trkSpots">
              <option value="2" ${t.spotsPerSpace===2?'selected':''}>2 (race line + outside)</option>
              <option value="1" ${t.spotsPerSpace===1?'selected':''}>1</option>
            </select>
          </label>
          <label class="small">Finish Index<br><input id="trkFinish" type="number" min="0" max="${t.spacesCount-1}" value="${t.finishIndex}" /></label>
          <label class="small">Laps Required<br><input id="trkLaps" type="number" min="1" max="9" value="${t.lapsRequired}" /></label>
          <label class="small">Start Grid Index<br><input id="trkStart" type="number" min="0" max="${t.spacesCount-1}" value="${t.startGridStartIndex||2}" /></label>
          <div class="small muted" style="align-self:end">Corners editable in Track Editor.</div>
        </div>
        <div class="row" style="margin-top:10px">
          <button class="btn small" data-act="applyTrackBasics">Apply Track Basics</button>
          <span class="small muted">Current corners: ${(t.corners||[]).map(c=>`@${c.cornerLineIndex}≤${c.speedLimit}`).join(', ')||'none'}</span>
        </div>
      </div>

      <div class="hr"></div>

      <div class="note">
        <div class="row" style="justify-content:space-between">
          <div>
            <strong>Players</strong>
            <div class="small muted">1–6 players. You can add 1–2 dummy AI cars if you like.</div>
          </div>
          <div class="row">
            <button class="btn small" data-act="addHuman">+ Human</button>
            <button class="btn small" data-act="addAI">+ AI</button>
          </div>
        </div>
        <div class="grid2" style="margin-top:10px">
          <label class="small">Default Heat in Engine<br><input id="cfgHeat" type="number" min="0" max="12" value="6" /></label>
          <label class="small">Default Stress in Deck<br><input id="cfgStress" type="number" min="0" max="8" value="3" /></label>
        </div>
        <div class="row" style="margin-top:10px">
          <button class="btn small" data-act="randomizeGrid">Randomize Starting Grid</button>
          <span class="small muted">Starting grid fills spots in ascending order.</span>
        </div>
        <div class="hr"></div>
        <div class="grid2">${playerRows || '<div class="muted">Add at least 1 player.</div>'}</div>
      </div>

      <div class="hr"></div>

      <div class="note">
        <div class="row" style="justify-content:space-between">
          <div>
            <strong>Advanced Modules</strong>
            <div class="small muted">Optional: Garage Draft (custom upgrades) and Weather/Road Conditions (sectors & corners).</div>
          </div>
          <div class="row">
            <span class="tag2">${G.modules.garage?'GARAGE':'Garage off'}</span>
            <span class="tag2">${G.modules.weatherRoad?'WEATHER/ROAD':'Weather off'}</span>
          </div>
        </div>
        <div class="grid3" style="margin-top:10px">
          <label class="small">
            <input type="checkbox" id="modGarage" ${G.modules.garage?'checked':''} ${G.modules.championship?'disabled':''}/> Garage Draft
            <div class="muted" style="margin-top:4px">Replace starting upgrades with a 3-pick draft.</div>
          </label>
          <label class="small">
            <input type="checkbox" id="modWeather" ${(G.modules.championship||G.modules.weatherRoad)?'checked':''} ${G.modules.championship?'disabled':''}/> Weather & Road
            <div class="muted" style="margin-top:4px">Draw 1 weather + 1 road token per corner.</div>
          </label>
          <label class="small">Upgrade Pool
            <select id="upgLevel">
              <option value="basic" ${G.modules.upgradePool==='basic'?'selected':''}>Basic (recommended)</option>
              <option value="advanced" ${G.modules.upgradePool==='advanced'?'selected':''}>Advanced</option>
              <option value="all" ${G.modules.upgradePool==='all'?'selected':''}>All</option>
            </select>
            <div class="muted" style="margin-top:4px">Pool selector is reserved for future card variety (UI only for now).</div>
          </label>
        </div>
      </div>

      
      <div class="note">
        <div class="row" style="justify-content:space-between">
          <div>
            <strong>Championship Mode</strong>
            <div class="small muted">Season play with persistent Upgrades + Sponsorship. (Legends skipped.)</div>
          </div>
          <div class="row">
            <span class="tag2">${G.modules.championship?'CHAMPIONSHIP':'Championship off'}</span>
          </div>
        </div>
        <div class="grid3" style="margin-top:10px">
          <label class="small">
            <input type="checkbox" id="modChamp" ${G.modules.championship?'checked':''}/> Enable Championship
            <div class="muted" style="margin-top:4px">If enabled, Weather/Road is forced ON and Garage Draft is disabled.</div>
          </label>
          <label class="small">Races in season<br><input id="champRaces" type="number" min="1" max="12" value="${G.champConfig?.races||4}" /></label>
          <label class="small">Start Sponsorship / race<br><input id="champStartSpon" type="number" min="0" max="5" value="${G.champConfig?.startSponsorship||1}" /></label>
          <label class="small">Schedule preset<br>
            <select id="champSchedule">
              <option value="mix" ${(G.champConfig?.schedulePreset||'mix')==='mix'?'selected':''}>Mixed (random from presets)</option>
              <option value="us" ${(G.champConfig?.schedulePreset||'mix')==='us'?'selected':''}>US track only</option>
            </select>
          </label>
          <label class="small">Press corners<br>
            <select id="champPressMode">
              <option value="first" ${(G.champConfig?.pressCornersMode||'first')==='first'?'selected':''}>First corner only</option>
              <option value="random" ${(G.champConfig?.pressCornersMode||'first')==='random'?'selected':''}>Random corner</option>
            </select>
          </label>
          <label class="small">Points (CSV, from 1st)<br><input id="champPoints" value="${(G.champConfig?.points||[10,6,4,3,2,1]).join(',')}" /></label>
        </div>
      </div>
<div class="hr"></div>

      <div class="row" style="justify-content:space-between">
        <div class="note" style="flex:1">
          <strong>Ready?</strong>
          <div class="small muted">Start the race: build decks (12 Basic + 3 Starting Upgrades + Stress) and place Heat in engine. Draw 7.</div>
        </div>
        <button class="btn primary" data-act="start">Start Race</button>
      </div>

      <div class="note small" style="margin-top:10px">
        <div><strong>Core rules implemented</strong>: shift gears, play cards (no Heat), reveal & move, stress randomness (+), adrenaline for last car(s), cooldown, boost, slipstream, corner checks + spin out, discard restrictions, replenish + reshuffle, finish rules.</div>
      </div>
    `;
  }

  function hookSetupUI(){
    $$('[data-act]', $('#rightPanel')).forEach(el => {
      el.addEventListener('click', () => {
        const act = el.getAttribute('data-act');
        if (act === 'addHuman') addPlayer(false);
        if (act === 'addAI') addPlayer(true);
        if (act === 'start') startRace();
        if (act === 'randomizeGrid') { pushHistory('Randomize starting grid'); randomizeStartingGrid(); renderAll(); }
        if (act === 'resetTrack') { pushHistory('Reset track'); setTrack(DEFAULT_TRACK, {persist:true, presetId:'demo', remapPositions:true}); renderAll(); }
        if (act === 'applyTrackBasics') { pushHistory('Apply track basics'); applyTrackBasics(); renderAll(); }
        if (act === 'setSeed') { pushHistory('Set seed'); setSeedFromInput(); renderAll(); }
      });
    });

    // Advanced module toggles
    const cbGarage = $('#modGarage');
    if (cbGarage) cbGarage.addEventListener('change', ()=>{
      pushHistory('Toggle Garage Draft');
      G.modules.garage = cbGarage.checked;
      renderAll();
    });
    const cbWeather = $('#modWeather');
    if (cbWeather) cbWeather.addEventListener('change', ()=>{
      pushHistory('Toggle Weather/Road');
      G.modules.weatherRoad = cbWeather.checked;
      renderAll();
    });

    // Championship toggle + settings
    const cbChamp = $('#modChamp');
    if (cbChamp) cbChamp.addEventListener('change', ()=>{
      pushHistory('Toggle Championship');
      G.modules.championship = cbChamp.checked;
      if (G.modules.championship){
        // Championship forces Weather/Road on, and disables Garage Draft.
        G.modules.weatherRoad = true;
        G.modules.garage = false;
      }
      renderAll();
    });

    // Championship config inputs
    const champRaces = $('#champRaces');
    if (champRaces) champRaces.addEventListener('change', ()=>{
      G.champConfig.races = clamp(parseInt(champRaces.value,10)||4, 1, 12);
    });
    const champStartSpon = $('#champStartSpon');
    if (champStartSpon) champStartSpon.addEventListener('change', ()=>{
      G.champConfig.startSponsorship = clamp(parseInt(champStartSpon.value,10)||0, 0, 5);
    });
    const champSchedule = $('#champSchedule');
    if (champSchedule) champSchedule.addEventListener('change', ()=>{
      G.champConfig.schedulePreset = champSchedule.value || 'mix';
    });
    const champPressMode = $('#champPressMode');
    if (champPressMode) champPressMode.addEventListener('change', ()=>{
      G.champConfig.pressCornersMode = champPressMode.value || 'first';
    });
    const champPoints = $('#champPoints');
    if (champPoints) champPoints.addEventListener('change', ()=>{
      const arr = (champPoints.value||'').split(',').map(x=>parseInt(x.trim(),10)).filter(x=>Number.isFinite(x) && x>=0);
      if (arr.length) G.champConfig.points = arr;
    });
    const selPool = $('#upgLevel');
    if (selPool) selPool.addEventListener('change', ()=>{
      pushHistory('Change Upgrade Pool');
      G.modules.upgradePool = selPool.value;
      renderAll();
    });


    // Track preset selection
    const trackSel = $('#trackPresetSel');
    if (trackSel) trackSel.addEventListener('change', ()=>{
      const id = trackSel.value;
      pushHistory('Select track preset');
      if (id === 'custom'){
        const ct = loadCustomTrack();
        setTrack(ct, {persist:true, presetId:'custom', remapPositions:true});
      } else {
        const preset = getPresetById(id);
        if (preset && preset.track){
          setTrack(preset.track, {persist:true, presetId:id, remapPositions:true});
        } else {
          setTrack(DEFAULT_TRACK, {persist:true, presetId:'demo', remapPositions:true});
        }
      }
      // Track change resets module token placement
      renderAll();
    });

    // Custom track preset actions
    const nameInp = $('#presetNameInput');
    const actSaveNew = $('[data-act="savePresetNew"]', $('#rightPanel'));
    if (actSaveNew) actSaveNew.addEventListener('click', ()=>{
      pushHistory('Save track preset as new');
      const nm = ((nameInp && nameInp.value)||'').trim() || 'My Track Preset';
      const id = makeUserPresetId();
      // Clone current track, assign id + name
      let tr;
      try{ tr = (typeof structuredClone==='function') ? structuredClone(G.track) : JSON.parse(JSON.stringify(G.track)); }
      catch(e){ tr = JSON.parse(JSON.stringify(G.track)); }
      tr.id = id; tr.name = nm;
      const nt = normalizeTrack(tr);
      const list = loadCustomPresets();
      list.push({id, name:nm, track: nt});
      saveCustomPresets(list);
      setTrack(nt, {persist:true, presetId:id, remapPositions:true});
      renderAll();
    });

    const actSaveOver = $('[data-act="savePresetOverwrite"]', $('#rightPanel'));
    if (actSaveOver) actSaveOver.addEventListener('click', ()=>{
      const pid = $('#trackPresetSel')?.value || G.trackPresetId;
      if (!isUserPresetId(pid)){ toast('Select a saved preset first.'); return; }
      pushHistory('Save track preset');
      const nm = ((nameInp && nameInp.value)||'').trim() || (getPresetById(pid)?.name||'Saved Preset');
      let tr;
      try{ tr = (typeof structuredClone==='function') ? structuredClone(G.track) : JSON.parse(JSON.stringify(G.track)); }
      catch(e){ tr = JSON.parse(JSON.stringify(G.track)); }
      tr.id = pid; tr.name = nm;
      const nt = normalizeTrack(tr);
      const list = loadCustomPresets();
      const ix = list.findIndex(p=>p.id===pid);
      if (ix>=0) list[ix] = {id:pid, name:nm, track: nt};
      saveCustomPresets(list);
      setTrack(nt, {persist:true, presetId:pid, remapPositions:true});
      renderAll();
    });

    const actRename = $('[data-act="renamePreset"]', $('#rightPanel'));
    if (actRename) actRename.addEventListener('click', ()=>{
      const pid = $('#trackPresetSel')?.value || G.trackPresetId;
      if (!isUserPresetId(pid)){ toast('Select a saved preset first.'); return; }
      const nm = ((nameInp && nameInp.value)||'').trim();
      if (!nm){ toast('Enter a name first.'); return; }
      pushHistory('Rename track preset');
      const list = loadCustomPresets();
      const ix = list.findIndex(p=>p.id===pid);
      if (ix>=0){
        list[ix].name = nm;
        // Keep track name in sync
        if (list[ix].track){ list[ix].track.name = nm; }
        saveCustomPresets(list);
        // Also update current track if selected
        if (G.trackPresetId === pid){
          G.track.name = nm;
          try{ localStorage.setItem(TRACK_SELECTED_KEY, pid); }catch(e){}
        }
        renderAll();
      }
    });

    const actDel = $('[data-act="deletePreset"]', $('#rightPanel'));
    if (actDel) actDel.addEventListener('click', ()=>{
      const pid = $('#trackPresetSel')?.value || G.trackPresetId;
      if (!isUserPresetId(pid)){ toast('Select a saved preset first.'); return; }
      if (!confirm('Delete this saved preset?')) return;
      pushHistory('Delete track preset');
      const list = loadCustomPresets().filter(p=>p.id!==pid);
      saveCustomPresets(list);
      // Fall back to Custom edits
      const ct = loadCustomTrack();
      setTrack(ct, {persist:true, presetId:'custom', remapPositions:true});
      renderAll();
    });



    // Remove player
    $$('[data-act="rmPlayer"]', $('#rightPanel')).forEach(btn => {
      btn.addEventListener('click', () => {
        const idx = parseInt(btn.getAttribute('data-idx'),10);
        pushHistory('Remove player');
        G.players.splice(idx,1);
        renderAll();
      });
    });

    // Player edits
    $$('[data-act="pName"]', $('#rightPanel')).forEach(inp => {
      inp.addEventListener('input', () => {
        const idx = parseInt(inp.getAttribute('data-idx'),10);
        G.players[idx].name = inp.value.trim() || G.players[idx].color;
        renderTrack();
      });
    });
    $$('[data-act="pColor"]', $('#rightPanel')).forEach(inp => {
      inp.addEventListener('input', () => {
        const idx = parseInt(inp.getAttribute('data-idx'),10);
        G.players[idx].color = inp.value;
        renderTrack();
      });
    });
    $$('[data-act="pAI"]', $('#rightPanel')).forEach(sel => {
      sel.addEventListener('change', () => {
        const idx = parseInt(sel.getAttribute('data-idx'),10);
        G.players[idx].isAI = sel.value === '1';
        renderTrack();
      });
    });
  }

  
  /***********************
   * Advanced Modules: Garage Draft + Weather/Road
   ***********************/
  const WEATHER_SETUP_EFFECTS = [
    {key:'addStressShuffle', label:'Shuffle 1 extra Stress card into your deck', apply(p){ p.deck.push(makeStressCards(1,p.color)[0]); shuffleInPlace(p.deck, rng); }},
    {key:'removeStress', label:'Remove 1 Stress card from your deck', apply(p){ const i=p.deck.findIndex(c=>c && c.type==='stress'); if(i>=0) p.deck.splice(i,1); }},
    {key:'addHeatEngine', label:'Place 1 extra Heat card in your Engine', apply(p){ p.engine.push(...makeHeatCards(1,p.color)); }},
    {key:'removeHeatEngine', label:'Remove 1 Heat card from your Engine', apply(p){ if(p.engine.length) p.engine.pop(); }},
    {key:'shuffleHeat3', label:'Shuffle 3 Heat cards from engine into your draw deck', apply(p){ const n=Math.min(3,p.engine.length); const moved=p.engine.splice(0,n); for(const c of moved){ p.deck.push(c); } shuffleInPlace(p.deck, rng); }},
    {key:'discardHeat3', label:'Place 3 Heat cards from engine into your discard pile', apply(p){ const n=Math.min(3,p.engine.length); const moved=p.engine.splice(0,n); discardCards(p,moved); }},
  ];

  const WEATHER_SECTOR_EFFECTS = [
    {key:'slipPlus2', label:'Slipstream boost (+2 extra spaces)', effect(p){ return {slipBonus:2}; }},
    {key:'noSlip', label:'No slipstream (cannot start here)', effect(p){ return {noSlip:true}; }},
    {key:'coolingBonus', label:'Cooling Bonus (+1 Cooldown)', effect(p){ return {cooldownBonus:1}; }},
    {key:'noCooling', label:'No cooling (Cooldown not allowed)', effect(p){ return {noCooling:true}; }},
  ];

  function initWeatherRoadIfEnabled(){
    if (!G.modules.weatherRoad) { G.weatherRoad = null; return; }
    const corners = (G.track.corners||[]).slice().sort((a,b)=>a.cornerLineIndex-b.cornerLineIndex);
    if (!corners.length){
      // Still allow weather setup even without corners
      corners.push({cornerLineIndex: Math.floor(G.track.spacesCount/2), speedLimit: 7});
      G.track.corners = corners;
    }
    // Choose one of 6 weather tokens (fixed setup effects, sector effects cycle)
    const ws = WEATHER_SETUP_EFFECTS.slice();
    shuffleInPlace(ws, rng);
    const we = WEATHER_SECTOR_EFFECTS.slice();
    shuffleInPlace(we, rng);
    const weatherToken = {
      id: uid('w'),
      setupKey: ws[0].key,
      setupLabel: ws[0].label,
      sectorKey: we[0].key,
      sectorLabel: we[0].label,
      // display helpers for UI
      label: ws[0].label,
      desc: `Setup: ${ws[0].label} • Sector: ${we[0].label}`
    };

    // Build 12 road tokens (6 corner tokens + 6 sector tokens)
    const roadTokens = [];
    const mk = (kind, key, label, mandatory) => ({id: uid('rt'), kind, key, label, mandatory: !!mandatory});
    // Corner tokens (duplicate each twice)
    for (let i=0;i<2;i++){
      roadTokens.push(mk('corner','limitPlus','Speed Limit +1', true));
      roadTokens.push(mk('corner','limitMinus','Speed Limit -1', true));
      roadTokens.push(mk('corner','overheat','Overheat (+1 Heat cost if overspeed)', true));
    }
    // Sector tokens (duplicate each twice)
    for (let i=0;i<2;i++){
      roadTokens.push(mk('sector','slipPlus1','Slipstream boost (+1 extra space)', false));
      roadTokens.push(mk('sector','heatControl','Heat control (Boost costs 0 Heat here)', false));
      roadTokens.push(mk('sector','weather','Weather applies in this sector', false));
    }
    shuffleInPlace(roadTokens, rng);

    const roadCorner = {};
    const roadSector = {};

    for (let i=0;i<corners.length;i++){
      const c = corners[i];
      const tok = roadTokens.pop();
      if (tok.kind === 'corner'){
        roadCorner[c.cornerLineIndex] = tok;
      } else {
        // sector token applies to sector after this corner line until next corner
        roadSector[c.cornerLineIndex] = tok;
      }
    }
// Ensure completeness: every corner has BOTH a corner-token slot and a sector-token slot.
// Officially, Road tokens drawn per corner may result in no sector token for a sector; for this simulator's
// Weather module we enforce at least a "Clear" sector effect for every sector so effects are never missing.
for (let i=0;i<corners.length;i++){
  const idx = corners[i].cornerLineIndex;
  if (!roadCorner[idx]){
    roadCorner[idx] = mk('corner','clear','Clear corner (no change)', false);
  }
  if (!roadSector[idx]){
    roadSector[idx] = mk('sector','clear','Clear sector (no special effect)', false);
  }
}
// Ensure at least one sector is marked as the Weather sector so the Weather token's sector effect is actually used.
let hasWeatherSector = false;
for (const k in roadSector){
  if (roadSector[k] && roadSector[k].key === 'weather') { hasWeatherSector = true; break; }
}
if (!hasWeatherSector && corners.length){
  const pick = corners[Math.floor(rng()*corners.length)].cornerLineIndex;
  roadSector[pick] = mk('sector','weather','Weather applies in this sector', false);
}


    // Precompute sectors
    const sectors = [];
    for (let i=0;i<corners.length;i++){
      const start = corners[i].cornerLineIndex;
      const end = corners[(i+1)%corners.length].cornerLineIndex;
      const wrap = end <= start;
      sectors.push({start, end, wrap, token: roadSector[start] || null});
    }

    G.weatherRoad = {enabled:true, weatherToken, roadCorner, roadSector, corners, sectors};
    log(`Weather/Road enabled: Weather = ${weatherToken.setupLabel} • Sector effect = ${weatherToken.sectorLabel}.`);
    // brief road summary
    const csum = corners.map(c=>{
      const t = roadCorner[c.cornerLineIndex] || roadSector[c.cornerLineIndex];
      return t ? `@${c.cornerLineIndex}:${t.kind==='corner'?'Corner':'Sector'}(${t.label})` : `@${c.cornerLineIndex}:—`;
    }).join(' | ');
    log(`Road Conditions: ${csum}`);
  }

  function applyWeatherSetupToAllPlayers(){
    if (!G.weatherRoad) return;
    const tok = G.weatherRoad.weatherToken;
    const rule = WEATHER_SETUP_EFFECTS.find(x=>x.key===tok.setupKey);
    if (!rule) return;
    for (const p of G.players){
      if (p.finished) continue;
      rule.apply(p);
    }
  }

  function sectorForIdx(idx){
    if (!G.weatherRoad || !G.weatherRoad.sectors) return null;
    for (const s of G.weatherRoad.sectors){
      if (!s.wrap){
        if (idx > s.start && idx <= s.end) return s; // between cornerLine and next cornerLine inclusive of end
      } else {
        if (idx > s.start || idx <= s.end) return s;
      }
    }
    return null;
  }

  function sectorEffectsForPlayer(p, when){
    // when: 'react' | 'boost' | 'slip'
    const out = {slipBonus:0, noSlip:false, boostFree:false, cooldownBonus:0, noCooling:false};
    if (!G.weatherRoad) return out;
    const s = sectorForIdx(p.pos.idx);
    if (s && s.token){
      if (s.token.key === 'slipPlus1') out.slipBonus += 1;
      if (s.token.key === 'heatControl') out.boostFree = true;
      if (s.token.key === 'weather'){
        const w = WEATHER_SECTOR_EFFECTS.find(x=>x.key===G.weatherRoad.weatherToken.sectorKey);
        if (w){
          const eff = w.effect(p);
          if (eff.slipBonus) out.slipBonus += eff.slipBonus;
          if (eff.noSlip) out.noSlip = true;
          if (eff.cooldownBonus) out.cooldownBonus += eff.cooldownBonus;
          if (eff.noCooling) out.noCooling = true;
        }
      }
    }
    return out;
  }

  function cornerAdjustments(cornerLineIndex){
    if (!G.weatherRoad) return {limitMod:0, overheat:false};
    const tok = G.weatherRoad.roadCorner[cornerLineIndex];
    if (!tok) return {limitMod:0, overheat:false};
    if (tok.key === 'limitPlus') return {limitMod: +1, overheat:false};
    if (tok.key === 'limitMinus') return {limitMod: -1, overheat:false};
    if (tok.key === 'overheat') return {limitMod: 0, overheat:true};
    return {limitMod:0, overheat:false};
  }

  
  // Garage Draft (3 upgrades each; hotseat) — implemented per Advanced Play booklet:
  // 3 rounds of drafting; each round: market = (players + 3) face-up cards; everyone takes 1 in order; discard leftovers; new market next round.
  // (We implement an offline-friendly approximation of the full Upgrade decks: Basic = 34 cards (17×2); Advanced = 62 cards (20×3 + 2 extras).)

  const UPGRADE_DEFS = [
    // --- Basic (1–17) ---
    {num:1,  lvl:'basic', name:'4 Wheel Drive', speed:4, plus:1, cooldown:0, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false},
    {num:2,  lvl:'basic', name:'4 Wheel Drive', speed:0, plus:3, cooldown:0, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false},
    {num:3,  lvl:'basic', name:'4 Wheel Drive', speed:0, plus:1, cooldown:3, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false},
    {num:4,  lvl:'basic', name:'Bodywork',     speed:3, plus:0, cooldown:0, reduceStress:2, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false},
    {num:5,  lvl:'basic', name:'Bodywork',     speed:5, plus:0, cooldown:0, reduceStress:1, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false},
    {num:6,  lvl:'basic', name:'Bodywork',     speed:1, plus:0, cooldown:0, reduceStress:3, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false},
    {num:7,  lvl:'basic', name:'Brakes',       speed:null, plus:0, cooldown:0, reduceStress:0, slipBonus:0, payHeat:1, choices:[1,2,3,4], limitMod:0, overheat:false},
    {num:8,  lvl:'basic', name:'Brakes',       speed:null, plus:0, cooldown:0, reduceStress:0, slipBonus:0, payHeat:0, choices:[1,3],     limitMod:0, overheat:false},
    {num:9,  lvl:'basic', name:'Brakes',       speed:null, plus:0, cooldown:0, reduceStress:0, slipBonus:0, payHeat:0, choices:[2,4],     limitMod:0, overheat:false},
    {num:10, lvl:'basic', name:'Brakes',       speed:null, plus:0, cooldown:0, reduceStress:0, slipBonus:0, payHeat:0, choices:[1,5],     limitMod:0, overheat:false},
    {num:11, lvl:'basic', name:'Cooling System', speed:6, plus:0, cooldown:1, reduceStress:0, slipBonus:0, payHeat:1, choices:null, limitMod:0, overheat:false},
    {num:12, lvl:'basic', name:'Cooling System', speed:1, plus:0, cooldown:2, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false},
    {num:13, lvl:'basic', name:'Cooling System', speed:3, plus:0, cooldown:1, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false},
    {num:14, lvl:'basic', name:'R.P.M.',       speed:1, plus:0, cooldown:0, reduceStress:0, slipBonus:1, payHeat:0, choices:null, limitMod:0, overheat:false},
    {num:15, lvl:'basic', name:'R.P.M.',       speed:2, plus:0, cooldown:0, reduceStress:0, slipBonus:2, payHeat:0, choices:null, limitMod:0, overheat:false},
    {num:16, lvl:'basic', name:'R.P.M.',       speed:3, plus:0, cooldown:0, reduceStress:0, slipBonus:2, payHeat:0, choices:null, limitMod:0, overheat:false},
    {num:17, lvl:'basic', name:'Heat',         speed:0, plus:0, cooldown:0, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false, behavesLikeHeat:true},

    // --- Advanced (18–37) --- (partial implementation of extra icons; enough for drafting + speed + corner-relevant effects)
    {num:18, lvl:'adv', name:'Bodywork', speed:6, plus:0, cooldown:0, reduceStress:3, slipBonus:0, payHeat:1, choices:null, limitMod:0, overheat:false, scrap:0},
    {num:19, lvl:'adv', name:'Bodywork', speed:2, plus:0, cooldown:0, reduceStress:1, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false, scrap:2},
    {num:20, lvl:'adv', name:'Bodywork', speed:2, plus:0, cooldown:0, reduceStress:1, slipBonus:1, payHeat:0, choices:null, limitMod:0, overheat:false, scrap:0},
    {num:21, lvl:'adv', name:'Cooling System', speed:4, plus:0, cooldown:1, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false, scrap:2},
    {num:22, lvl:'adv', name:'Fuel', speed:2, plus:0, cooldown:0, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false, salvage:2},
    {num:23, lvl:'adv', name:'Fuel', speed:0, plus:1, cooldown:1, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false, salvage:2},
    {num:24, lvl:'adv', name:'Gas Pedal', speed:1, plus:0, cooldown:0, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false, scrap:1, directPlay:true},
    {num:25, lvl:'adv', name:'Gas Pedal', speed:2, plus:0, cooldown:0, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false, scrap:2, directPlay:true},
    {num:26, lvl:'adv', name:'Gas Pedal', speed:3, plus:0, cooldown:0, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false, scrap:3, directPlay:true},
    {num:27, lvl:'adv', name:'Gas Pedal', speed:4, plus:0, cooldown:1, reduceStress:0, slipBonus:0, payHeat:1, choices:null, limitMod:0, overheat:false, scrap:0, directPlay:true},
    {num:28, lvl:'adv', name:'Gas Pedal', speed:1, plus:0, cooldown:0, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false, scrap:5, accelerate:true, directPlay:true},
    {num:29, lvl:'adv', name:'R.P.M.', speed:0, plus:1, cooldown:0, reduceStress:0, slipBonus:3, payHeat:0, choices:null, limitMod:0, overheat:false},
    {num:30, lvl:'adv', name:'R.P.M.', speed:1, plus:0, cooldown:0, reduceStress:0, slipBonus:3, payHeat:1, choices:null, limitMod:0, overheat:false},
    {num:31, lvl:'adv', name:'R.P.M.', speed:null, plus:0, cooldown:0, reduceStress:0, slipBonus:1, payHeat:0, choices:[1,2], limitMod:0, overheat:false},
    {num:32, lvl:'adv', name:'Suspension', speed:2, plus:0, cooldown:0, reduceStress:1, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false, refresh:true},
    {num:33, lvl:'adv', name:'Suspension', speed:2, plus:0, cooldown:1, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false, refresh:true},
    {num:34, lvl:'adv', name:'Suspension', speed:4, plus:0, cooldown:0, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:0, overheat:false, refresh:true},
    {num:35, lvl:'adv', name:'Suspension', speed:1, plus:0, cooldown:0, reduceStress:0, slipBonus:1, payHeat:0, choices:null, limitMod:0, overheat:false, refresh:true},
    {num:36, lvl:'adv', name:'Tyres', speed:2, plus:0, cooldown:3, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:-1, overheat:false},
    {num:37, lvl:'adv', name:'Tyres', speed:1, plus:0, cooldown:0, reduceStress:0, slipBonus:0, payHeat:0, choices:null, limitMod:+1, overheat:false, scrap:2},
  ];

  function buildUpgradeDeck(){
    const level = (G.modules && G.modules.upgradePool) ? G.modules.upgradePool : 'basic';
    const defsBasic = UPGRADE_DEFS.filter(d=>d.lvl==='basic');
    const defsAdv = UPGRADE_DEFS.filter(d=>d.lvl==='adv');

    let pool = [];
    if (level === 'basic'){
      for (const d of defsBasic){
        for (let k=0;k<2;k++) pool.push(makeUpgradeCardFromDef(d, k));
      }
    } else if (level === 'advanced'){
      for (const d of defsAdv){
        for (let k=0;k<3;k++) pool.push(makeUpgradeCardFromDef(d, k));
      }
      // pad to 62 with two extra random ones
      if (pool.length < 62){
        const extra = defsAdv.slice(0,2);
        for (let i=0;i<62-pool.length;i++){
          pool.push(makeUpgradeCardFromDef(extra[i%extra.length], 99+i));
        }
      }
    } else { // all
      // Basic 34 + Advanced 62
      for (const d of defsBasic){ for (let k=0;k<2;k++) pool.push(makeUpgradeCardFromDef(d, k)); }
      for (const d of defsAdv){ for (let k=0;k<3;k++) pool.push(makeUpgradeCardFromDef(d, k)); }
      if (pool.length < (34+62)){
        const extra = defsAdv.slice(0,2);
        for (let i=0;i<(34+62)-pool.length;i++){
          pool.push(makeUpgradeCardFromDef(extra[i%extra.length], 199+i));
        }
      }
    }
    shuffleInPlace(pool, rng);
    return pool;
  }

  function makeUpgradeCardFromDef(def, copyIdx){
    // If this upgrade is "Heat", represent it as an actual Heat card that clogs hand and cannot be played.
    if (def.behavesLikeHeat){
      const c = makeHeatCards(1, '#888')[0];
      c.id = uid('uH');
      c.origin = 'upgrade';
      c.upgNum = def.num;
      c.upgName = def.name;
      c.label = `Upgrade ${def.num}: ${def.name}`;
      return c;
    }
    const c = {
      id: uid('upg'),
      type: 'upgrade',
      upgNum: def.num,
      upgLevel: def.lvl,
      name: def.name,
      value: (typeof def.speed === 'number') ? def.speed : 0,
      choices: def.choices ? def.choices.slice() : null,
      chosen: null,
      plus: def.plus || 0,
      plusCards: [], // cards flipped for + symbols
      cool: def.cooldown || 0,
      reduceStress: def.reduceStress || 0,
      slipBonus: def.slipBonus || 0,
      payHeatCost: def.payHeat || 0,
      scrap: def.scrap || 0,
      limitMod: def.limitMod || 0,
      refresh: !!def.refresh,
      salvage: def.salvage || 0,
      directPlay: !!def.directPlay,
      accelerate: !!def.accelerate,
      label: `Upgrade ${def.num}: ${def.name}`
    };
    return c;
  }

  function initGarageDraft(){
    if (!G.modules.garage) { G.draft = null; return; }

    const pool = buildUpgradeDeck();
    const nPlayers = G.players.filter(p=>!p.finished).length;

    const d = {
      enabled:true,
      round:1,
      pool,
      discards:[],
      market:[],
      order:[],
      pickerIdx:0,
      pickedThisRound:0,
      picks:{}
    };
    for (const p of G.players){
      d.picks[p.id] = [];
    }

    function reshuffleIfNeeded(){
      if (d.pool.length === 0 && d.discards.length){
        d.pool = d.discards.splice(0, d.discards.length);
        shuffleInPlace(d.pool, rng);
      }
    }

    function dealMarket(){
      d.market = [];
      reshuffleIfNeeded();
      const want = nPlayers + 3;
      for (let i=0;i<want;i++){
        if (d.pool.length === 0){
          reshuffleIfNeeded();
        }
        if (d.pool.length === 0) break;
        d.market.push(d.pool.pop());
      }
    }

    function setOrderForRound(){
      const cars = sortedCars(true, false); // front to back on grid
      if (d.round === 2){
        // front to back
        d.order = cars.map(p=>p.id);
      } else {
        // back to front
        d.order = cars.slice().reverse().map(p=>p.id);
      }
      d.pickerIdx = 0;
      d.pickedThisRound = 0;
    }

    dealMarket();
    setOrderForRound();

    d.currentPlayerId = d.order[d.pickerIdx];

    G.draft = d;
    G.phase = PHASE.DRAFT;
    log(`Garage Draft begins: Round 1/3. Market size ${d.market.length} (players+3). Picker order: ${d.order.map(id=>pidToName(id)).join(' → ')}`);
  }

  function pidToName(pid){
    const p = G.players.find(x=>x.id===pid);
    return p ? p.name : pid;
  }

  function fmtUpgradeCardShort(c){
    if (!c) return '—';
    if (c.type==='heat' && c.origin==='upgrade') return `U${c.upgNum} Heat`;
    if (c.type!=='upgrade') return fmtCard(c);
    const plus = c.plus ? (' ' + '＋'.repeat(c.plus)) : '';
    const choice = c.choices ? ` [${c.choices.join('/')}]` : '';
    const icons = [];
    if (c.payHeatCost) icons.push(`Heat${c.payHeatCost}`);
    if (c.scrap) icons.push(`Scrap${c.scrap}`);
    if (c.limitMod) icons.push(`Limit${c.limitMod>0?'+':''}${c.limitMod}`);
    if (c.cool) icons.push(`Cool${c.cool}`);
    if (c.reduceStress) icons.push(`-Stress${c.reduceStress}`);
    if (c.slipBonus) icons.push(`Slip+${c.slipBonus}`);
    if (c.refresh) icons.push(`Refresh`);
    if (c.directPlay) icons.push(`Direct`);
    if (c.salvage) icons.push(`Salvage${c.salvage}`);
    if (c.accelerate) icons.push(`Accel`);
    return `U${c.upgNum} ${c.name}${choice} ${c.value}${plus}${icons.length?' • '+icons.join(', '):''}`.trim();
  }

  function fmtUpgradeCardBottom(c){
    if (!c) return '';
    // Small helper used in draft/hand UIs. Keep it robust even if new card fields appear.
    if (c.type==='heat' && c.origin==='upgrade') return 'Heat (upgrade)';
    if (c.type!=='upgrade') return '';
    const parts = [];
    if (Array.isArray(c.choices) && c.choices.length) parts.push(`Choice ${c.choices.join('/')}`);
    if (c.plus) parts.push(`＋${c.plus}`);
    if (c.payHeatCost) parts.push(`Pay Heat ${c.payHeatCost}`);
    if (c.cooldownBonus) parts.push(`Cooldown +${c.cooldownBonus}`);
    if (c.reduceStress) parts.push(`Reduce Stress ${c.reduceStress}`);
    if (c.salvage) parts.push(`Salvage ${c.salvage}`);
    if (c.refresh) parts.push('Refresh');
    if (c.limitMod) parts.push(`Limit ${c.limitMod>0?'+':''}${c.limitMod}`);
    if (c.slipBonus) parts.push(`Slip +${c.slipBonus}`);
    if (c.scrap) parts.push(`Scrap ${c.scrap}`);
    if (c.accelerate) parts.push('Accelerate');
    return parts.join(' • ');
  }


  
  function renderDraftUI(){
    const d = G.draft;
    if (!d) return `<div class="muted">Draft not initialized.</div>`;
    const current = G.players.find(p=>p.id===d.currentPlayerId);
    if (!current) return `<div class="muted">Draft error: no current player.</div>`;
    const picks = d.picks[current.id]||[];
    return `
      <div class="panel" style="margin-top:10px">
        <div class="row">
          <div style="font-weight:800">Garage Draft</div>
          <div class="small">Round ${d.round}/3 • Picker: <span class="pill">${escapeHtml(current.name)}</span> • Pick ${picks.length+1}/3</div>
        </div>
        <div class="small muted" style="margin-top:6px">
          Each round: pick 1 card (in order), then discard the remaining market and deal a fresh market.
        </div>

        <div class="row" style="margin-top:10px">
          <div class="small muted">Market</div>
          <div class="small muted">Deck ${d.pool.length} • Discard ${d.discards.length}</div>
        </div>

        <div class="market" id="marketGrid">
          ${d.market.map(c=>`<button class="cardBtn" data-act="pickUpg" data-id="${c.id}" ${current.isAI?'disabled':''} title="${escapeHtml(fmtUpgradeCardShort(c))}">
              <div class="cardFace">
                <div class="cardTitle">${escapeHtml(c.type==='upgrade' ? `U${c.upgNum} ${c.name}` : `U${c.upgNum||''} Heat`)}</div>
                <div class="cardBody">${escapeHtml(upgradeCardFaceText(c))}</div>
              </div>
            </button>`).join('')}
        </div>

        <div class="row" style="margin-top:10px">
          <div class="small muted">Your picks</div>
          <div class="small muted">${escapeHtml(picks.map(fmtUpgradeCardShort).join(' • ') || '—')}</div>
        </div>

        <div class="row" style="margin-top:10px">
          <button class="btn" id="btnDraftAuto" ${current.isAI?'disabled':''}>Auto-pick for me</button>
          <button class="btn" id="btnDraftForceFinish" title="Emergency: fill missing picks randomly (for debugging).">Force finish draft</button>
        </div>
      </div>
    `;
  }


function upgradeCardFaceText(c){
    if (!c) return '';
    if (c.type==='heat' && c.origin==='upgrade') return 'Acts as a Heat card (clogs hand).';
    if (c.type!=='upgrade') return '';
    const parts=[];
    if (c.choices) parts.push(`Speed: ${c.choices.join(' or ')}`);
    else parts.push(`Speed: ${c.value||0}`);
    if (c.plus) parts.push(`Boost symbol(s): ${c.plus}`);
    if (c.payHeatCost) parts.push(`Pay Heat: ${c.payHeatCost}`);
    if (c.scrap) parts.push(`Scrap: ${c.scrap}`);
    if (c.limitMod) parts.push(`Corner limit ${c.limitMod>0?'+':''}${c.limitMod} this turn`);
    if (c.cool) parts.push(`Cooldown: ${c.cool}`);
    if (c.reduceStress) parts.push(`Discard Stress: ${c.reduceStress}`);
    if (c.slipBonus) parts.push(`Slipstream +${c.slipBonus}`);
    if (c.refresh) parts.push(`Refresh (keep)`);
    if (c.directPlay) parts.push(`Direct Play`);
    if (c.salvage) parts.push(`Salvage: ${c.salvage}`);
    if (c.accelerate) parts.push(`Accelerate`);
    return parts.join('\n');
  }

  function hookDraftUI(){
    const d = G.draft;
    if (!d) return;
    const current = G.players.find(p=>p.id===d.currentPlayerId);
    const market = $('#marketGrid');

    if (market){
      $$('[data-act="pickUpg"]', market).forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const cid = btn.getAttribute('data-id');
          draftPick(cid, false);
        });
      });
    }

    const auto = $('#btnDraftAuto');
    if (auto){
      auto.addEventListener('click', ()=>{
        draftPick(null, true);
      });
    }
    const force = $('#btnDraftForceFinish');
    if (force){
      force.addEventListener('click', ()=>{
        pushHistory('Force finish draft');
        while (G.draft){
          const d2 = G.draft;
          const cur = G.players.find(p=>p.id===d2.currentPlayerId);
          if (!cur) break;
          const picks = d2.picks[cur.id]||[];
          if (picks.length>=3){
            // move to next
            advanceDraftPicker();
            continue;
          }
          // pick random
          draftPick(null, true);
        }
      });
    }

    // If current picker is AI, auto-pick
    if (current && current.isAI){
      if (!d._aiPicking){
        d._aiPicking = true;
        setTimeout(()=>{ d._aiPicking = false; draftPick(null,true); }, 120);
      }
    }
  }

  function draftPick(cardId, auto){
    const d = G.draft;
    if (!d) return;
    const pid = d.currentPlayerId;
    const p = G.players.find(x=>x.id===pid);
    if (!p) return;

    const picks = d.picks[pid] || (d.picks[pid]=[]);
    if (picks.length >= 3){
      advanceDraftPicker();
      return;
    }

    let chosen = null;
    if (cardId){
      const i = d.market.findIndex(c=>c.id===cardId);
      if (i>=0) chosen = d.market.splice(i,1)[0];
    }
    if (!chosen){
      // AI / auto: pick the best by heuristic (prefer cooldown if heat clogs, prefer slip/limit mods, avoid upgrade-heat)
      chosen = chooseUpgradeFromMarket(p, d.market);
      const i = d.market.findIndex(c=>c.id===chosen.id);
      if (i>=0) d.market.splice(i,1);
    }

    if (!chosen){
      // Shouldn't happen; if market empty, rebuild it.
      log(`Draft warning: market empty. Re-dealing market.`);
      dealNewMarketAndContinue();
      return;
    }

    picks.push(chosen);
    log(`${p.name} drafts ${fmtUpgradeCardShort(chosen)}.`);

    d.pickedThisRound++;

    // Move to next picker within this round, or end round when everyone picked
    if (d.pickedThisRound >= G.players.filter(x=>!x.finished).length){
      // discard leftovers
      if (d.market.length){
        d.discards.push(...d.market.splice(0, d.market.length));
      }
      d.round++;
      if (d.round <= 3){
        dealNewMarketAndContinue();
      } else {
        finalizeDraftAndStart();
      }
      return;
    }

    advanceDraftPicker();
  }

  function dealNewMarketAndContinue(){
    const d = G.draft;
    if (!d) return;

    // Deal new market (players+3)
    const nPlayers = G.players.filter(p=>!p.finished).length;

    if (d.pool.length === 0 && d.discards.length){
      d.pool = d.discards.splice(0, d.discards.length);
      shuffleInPlace(d.pool, rng);
    }

    d.market = [];
    for (let i=0;i<nPlayers+3;i++){
      if (d.pool.length === 0){
        if (d.discards.length){
          d.pool = d.discards.splice(0, d.discards.length);
          shuffleInPlace(d.pool, rng);
        }
      }
      if (d.pool.length === 0) break;
      d.market.push(d.pool.pop());
    }

    // Set pick order for round
    const cars = sortedCars(true, false); // front to back
    d.order = (d.round === 2) ? cars.map(p=>p.id) : cars.slice().reverse().map(p=>p.id);
    d.pickerIdx = 0;
    d.pickedThisRound = 0;
    d.currentPlayerId = d.order[d.pickerIdx];

    log(`Draft Round ${d.round}/3 begins. Picker order: ${d.order.map(pidToName).join(' → ')}`);
    renderAll();
    hookDraftUI();
  }

  function advanceDraftPicker(){
    const d = G.draft;
    if (!d) return false;

    const order = d.order || [];
    const n = order.length;
    if (!n){
      // No order? force finalize safeguards
      finalizeDraftAndStart();
      return false;
    }

    // Find next player in order who still needs picks (<3).
    for (let step=0; step<n; step++){
      d.pickerIdx = (d.pickerIdx + 1) % n;
      const pid = order[d.pickerIdx];
      const picks = d.picks[pid] || [];
      if (picks.length < 3){
        d.currentPlayerId = pid;
        renderAll();
        hookDraftUI();
        return true;
      }
    }

    // Everyone already has 3 picks — finalize the draft.
    finalizeDraftAndStart();
    return false;
  }

  function chooseUpgradeFromMarket(p, market){
    if (!market || !market.length) return null;

    const upcomingCorners = (G.track.corners||[]).slice().sort((a,b)=>a.cornerLineIndex-b.cornerLineIndex);
    const heatInHand = p.hand && p.hand.some(c=>c.type==='heat');
    function score(c){
      if (c.type==='heat' && c.origin==='upgrade') return -50;
      if (c.type!=='upgrade') return 0;
      let s = 0;
      s += (c.value||0);
      s += (c.plus||0)*1.2;
      s += (c.cool||0) * (heatInHand?2.0:1.0);
      s += (c.reduceStress||0) * 0.6;
      s += (c.slipBonus||0) * 0.7;
      s += Math.abs(c.limitMod||0) * 0.8;
      // penalize mandatory heat costs if engine low at start
      s -= (c.payHeatCost||0) * (p.engine && p.engine.length<3 ? 1.2 : 0.6);
      // penalize heavy scrap early
      s -= (c.scrap||0) * 0.2;
      return s + (rng()*0.001);
    }
    return market.slice().sort((a,b)=>score(b)-score(a))[0];
  }

  function finalizeDraftAndStart(){
    const d = G.draft;
    if (!d) return;

    // Ensure everyone has 3 picks (fail-safe)
    const live = G.players.filter(p=>!p.finished);
    for (const p of live){
      while ((d.picks[p.id]||[]).length < 3){
        // pull from market then pool
        let c = d.market.pop();
        if (!c) c = d.pool.pop();
        if (!c){
          if (d.discards.length){
            d.pool = d.discards.splice(0, d.discards.length);
            shuffleInPlace(d.pool, rng);
            c = d.pool.pop();
          }
        }
        if (!c) break;
        (d.picks[p.id]||[]).push(c);
      }
    }

    for (const p of live){
      const picks = d.picks[p.id] || [];
      p.deck.push(...picks);
      shuffleInPlace(p.deck, rng);
    }
    // leftovers are discarded (ignored)
    G.draft = null;
    log('Garage Draft complete. Each player has 3 Upgrade cards shuffled into their deck.');
    finalizeStartRaceIntoPlanning();
  }


  
  /***********************
   * Championship (Option A)
   * - Persistent Upgrades + Sponsorship across a season of races
   * - Per-race: Build Your Car (draft 1 Upgrade), then race
   * - Legends intentionally skipped for now
   ***********************/
  const CHAMP_DEFAULT_POINTS = [10,6,4,3,2,1];

  function buildSponsorshipDeck(){
    // Sponsorship cards (Championship). Text-only; no official art used.
    // These follow the official sponsorship card types (modeled mechanically).
    const defs = [
      {key:'aperaul', name:'APERAULT RPM Cie', value:1, desc:'Slipstream +2 this turn.', slipBonus:2},
      {key:'deangeli', name:'DE ANGELI WINGS Inc', value:3, desc:'Corner Speed Limit +1 this turn.', limitMod:1},
      {key:'dramdo', name:'DRAMDO BRAKES™', choices:[1,2,3,4], desc:'Choose 1/2/3/4 speed when revealed.'},
      {key:'fredo', name:'FREDO & F.LLO C.S.', value:4, desc:'Cooldown +2 (optional) during React.', cool:2},
      {key:'lord', name:'LORD & Co. T.B.', value:6, desc:'Speed 6.'}
    ];
    const deck = [];
    const COPIES = 7;
    for (const d of defs){
      for (let i=0;i<COPIES;i++){
        deck.push({
          id: uid(),
          type: 'sponsor',
          key: d.key,
          name: d.name,
          value: d.value,
          choices: d.choices,
          desc: d.desc,
          slipBonus: d.slipBonus||0,
          limitMod: d.limitMod||0,
          cool: d.cool||0
        });
      }
    }
    shuffleInPlace(deck, rng);
    return deck;
  }

  function champTrackSchedule(preset, races){
    const keys = Object.keys(TRACK_LIBRARY||{}).filter(k=>k!=='custom');
    if (!keys.length) return Array.from({length:races},()=>getInitialTrackPresetId());
    if (preset === 'us'){
      const usId = keys.find(k=>k.toLowerCase().includes('us')) || keys[0];
      return Array.from({length:races},()=>usId);
    }
    // mixed
    const out = [];
    for (let i=0;i<races;i++){
      out.push(keys[Math.floor(rng()*keys.length)]);
    }
    return out;
  }

  function champResetPlayerZones(p){
    p.engine = [];
    p.deck = [];
    p.discard = [];
    p.hand = [];
    p.play = [];
    p.publicTopDiscard = null;
    p.planned = {gearTarget:1, payHeatForShift:false, cards:[], locked:false};
    p.boostUsed = false;
    p.finished = false;
    p.removedFromTrack = false;
    p.finishRank = null;
    p.lap = 0;
    p.gear = 1;
    p._resolvedThisRound = false;
  }

  
  function ensureChamp(){
    // Ensure championship config/state exists even in older saves
    if (!G.champConfig){
      G.champConfig = {
        seasonPreset: '1961',
        races: 4,
        points: [14,10,6,3,2,1],
        startSponsors: 0,
        pressMode: 'default'
      };
    }
    if (!G.champ){
      G.champ = {
        enabled: false,
        seasonKey: G.champConfig.seasonPreset || '1961',
        raceIndex: 0,
        racesTotal: clamp((G.champConfig.races)||4, 1, 12),
        points: (G.champConfig.points)||[14,10,6,3,2,1],
        standings: [],
        results: [],
        sponsorDeck: [],
        sponsorUsedThisRace: [],
        pressCorners: []
      };
    }
    if (!Array.isArray(G.champ.results)) G.champ.results = [];
    if (!Array.isArray(G.champ.standings)) G.champ.standings = [];
    if (!Array.isArray(G.champ.sponsorDeck)) G.champ.sponsorDeck = [];
    if (!Array.isArray(G.champ.sponsorUsedThisRace)) G.champ.sponsorUsedThisRace = [];
    if (!Array.isArray(G.champ.pressCorners)) G.champ.pressCorners = [];
    return G.champ;
  }



  // Ensure discard-pick state is a Set (older saves / clones may turn Sets into arrays/objects)
  function ensureDiscardPickSet(){
    const dp = G._discardPick;
    if (dp instanceof Set) return dp;
    if (Array.isArray(dp)) { G._discardPick = new Set(dp); return G._discardPick; }
    if (dp && typeof dp === 'object') {
      // accept {id:true} maps
      const ids = Object.keys(dp).filter(k => dp[k]);
      G._discardPick = new Set(ids);
      return G._discardPick;
    }
    G._discardPick = new Set();
    return G._discardPick;
  }

function startChampionshipFromSetup({heat, stress}){
    pushHistory('Start Championship');
    ensureChamp();
    G.champ.enabled = true;
    G.champ.heat = heat;
    G.champ.stress = stress;
    G.champ.raceIndex = 0;
    G.champ.racesTotal = clamp((G.champConfig?.races)||4, 1, 12);
    G.champ.points = (G.champConfig?.points?.length ? G.champConfig.points.slice() : CHAMP_DEFAULT_POINTS.slice());
    G.champ.schedule = champTrackSchedule(G.champConfig?.schedulePreset||'mix', G.champ.racesTotal);

    // Fresh decks for season
    G.champ.sponsorDeck = buildSponsorshipDeck();
    G.champ.sponsorUsed = [];
    G.champ.upgradeDeck = buildUpgradeDeck(G.modules.upgradePool);
    G.champ.upgradeUsed = [];

    // Initialize player championship meta
    for (const p of G.players){
      champResetPlayerZones(p);
      p.champ = {points:0, upgrades:[], sponsors:[], lastFinish: 999};
    }

    // First race: random grid
    setTrack(getTrackPreset(G.champ.schedule[0]).track, {persist:false, presetId:G.champ.schedule[0], remapPositions:false});
    randomizeStartingGrid();

    // Race state reset
    G.phase = PHASE.DRAFT;
    G.round = 1;
    G.startedCount = 0;
    G.finishedOrder = [];
    G.resolveOrder = [];
    G.resolveIdx = 0;
    G.activeStep = STEP.REVEAL_MOVE;
    G.log = [];
    rebuildLog();
    log(`Championship begins: ${G.champ.racesTotal} race(s). Race 1 on "${getTrackPreset(G.champ.schedule[0]).name}".`);

    champSetupPressCorners();
    initChampBuildDraft();
    renderAll();
  }

  function champSetupPressCorners(){
    if (!G.champ) return;
    const corners = (G.track.corners||[]).slice().sort((a,b)=>a.cornerLineIndex-b.cornerLineIndex);
    if (!corners.length){ G.champ.pressCorners = []; return; }
    const mode = (G.champConfig?.pressCornersMode)||'first';
    if (mode === 'random'){
      const c = corners[Math.floor(rng()*corners.length)];
      G.champ.pressCorners = [c.cornerLineIndex];
    } else {
      G.champ.pressCorners = [corners[0].cornerLineIndex];
    }
  }

  function getTrackPreset(id){
    const entry = TRACK_LIBRARY[id] || TRACK_LIBRARY[getInitialTrackPresetId()];
    return entry || {name:'Track', track:getInitialTrack()};
  }

  function champGridOrderFrontToBack(){
    // standings desc points, tie by lastFinish asc
    const arr = G.players.slice().filter(p=>!p.removedFromTrack);
    arr.sort((a,b)=>{
      const ap=a.champ?.points||0, bp=b.champ?.points||0;
      if (bp!==ap) return bp-ap;
      const al=a.champ?.lastFinish||999, bl=b.champ?.lastFinish||999;
      if (al!==bl) return al-bl;
      return a.name.localeCompare(b.name);
    });
    return arr.map(p=>p.id);
  }

  function champPlaceGridFromFrontToBack(orderFront){
    // place back-to-front so frontmost ends up in the most forward slot
    const backToFront = orderFront.slice().reverse();
    const t = G.track;
    let idx = t.startGridStartIndex ?? 0;
    let lane = 0;
    for (const pid of backToFront){
      const p = G.players.find(x=>x.id===pid);
      if (!p) continue;
      const placed = placeWithBlocking(p, idx);
      p.pos.idx = placed.idx;
      p.pos.lane = placed.lane;
      // alternate lanes then advance
      if (t.spotsPerSpace === 1){ lane = 0; idx = stepForward(idx); }
      else {
        if (lane===0){ lane = 1; p.pos.lane = 0; } // keep RL preference in blocking logic
        else { lane = 0; idx = stepForward(idx); }
      }
      if (t.spotsPerSpace===2){
        // enforce desired lane: first car on a space goes RL, second goes OUT
        const occ = occupiedAt(idx);
      }
    }
  }

  function champBuildRaceDecksAndStart(){
    // rebuild every player's race deck from base + owned upgrades + owned sponsors
    const heat = G.champ.heat;
    const stress = G.champ.stress;

    for (const p of G.players){
      champResetPlayerZones(p);
      const base = makeBasicDeck(p.color);
      const stressCards = makeStressCards(stress, p.color);
      const upgs = (p.champ?.upgrades||[]).map(c=>deepClone(c));
      const spons = (p.champ?.sponsors||[]).map(c=>deepClone(c));
      // reset variable choices each race
      for (const c of [...upgs, ...spons]){
        if (c && c.choices) c.chosen = null;
      }
      p.deck = base.concat(stressCards, upgs, spons);
      shuffleInPlace(p.deck, rng);
      p.engine = makeHeatCards(heat, p.color);
      p.hand = [];
      p.discard = [];
      p.play = [];
      p.gear = 1;
      p.lap = 0;
      p.finished = false;
      p.removedFromTrack = false;
      p.finishRank = null;
      // draw 7
      for (let i=0;i<7;i++){
        const c = drawFromDeck(p, {allowReshuffle:true});
        if (c) p.hand.push(c);
      }
      // start sponsorship for this race (event)
      const nS = clamp(G.champConfig?.startSponsorship||1, 0, 5);
      for (let i=0;i<nS;i++){
        const sp = champDrawSponsorCard();
        if (sp){
          p.champ.sponsors.push(deepClone(sp));
          p.hand.push(sp);
        }
      }
    }

    // Set starting grid based on standings from race 2 onward
    if (G.champ.raceIndex > 0){
      const frontOrder = champGridOrderFrontToBack();
      champPlaceGridFromFrontToBack(frontOrder);
      log('Starting grid set by Championship standings.');
    }

    initWeatherRoadIfEnabled();
    finalizeStartRaceIntoPlanning();
  }

  function champDrawSponsorCard(){
    ensureChamp();
    if (!G.champ.sponsorDeck.length){
      if (G.champ.sponsorUsed.length){
        G.champ.sponsorDeck = G.champ.sponsorUsed.splice(0, G.champ.sponsorUsed.length);
        shuffleInPlace(G.champ.sponsorDeck, rng);
      }
    }
    const c = G.champ.sponsorDeck.pop();
    return c ? deepClone(c) : null;
  }

  function champAwardSponsorToPlayer(p, reason, cornerIdx=null){
    if (!G.modules.championship || !G.champ) return;
    const card = champDrawSponsorCard();
    if (!card){ log(`${p.name} would gain a Sponsorship, but the deck is empty.`); return; }
    p.champ.sponsors.push(deepClone(card));
    p.discard.push(card);
    p.publicTopDiscard = card;
    if (cornerIdx!=null){
      log(`${p.name} earns a Sponsorship at Press Corner @${cornerIdx} (${reason}).`);
    } else {
      log(`${p.name} earns a Sponsorship (${reason}).`);
    }
  }

  function isPressCorner(idx){
    return !!(G.champ && (G.champ.pressCorners||[]).includes(idx));
  }

  function initChampBuildDraft(){
    ensureChamp();
    const live = G.players.filter(p=>!p.finished);
    const order = live.slice().sort((a,b)=>{
      // worst-to-best picks first (points asc; lastFinish desc)
      const ap=a.champ?.points||0, bp=b.champ?.points||0;
      if (ap!==bp) return ap-bp;
      const al=a.champ?.lastFinish||999, bl=b.champ?.lastFinish||999;
      if (al!==bl) return bl-al;
      return a.name.localeCompare(b.name);
    }).map(p=>p.id);

    // Deal market
    const need = order.length + 3;
    const market = [];
    while (market.length < need){
      if (!G.champ.upgradeDeck.length){
        if (G.champ.upgradeUsed.length){
          G.champ.upgradeDeck = G.champ.upgradeUsed.splice(0, G.champ.upgradeUsed.length);
          shuffleInPlace(G.champ.upgradeDeck, rng);
        } else break;
      }
      const c = G.champ.upgradeDeck.pop();
      if (!c) break;
      market.push(deepClone(c));
    }

    G.draft = {
      kind:'champBuild',
      order,
      pickerIdx: 0,
      currentPlayerId: order[0],
      market,
      picks: {},
      selectedId: null,
      stage:'pick',
      swapUsed:false
    };

    log('Build Your Car: each player drafts 1 Upgrade (worst→best). Last picker may optionally swap after picking.');
  }

  function renderChampDraftUI(){
    const d = G.draft;
    if (!d) return '';
    const pid = d.currentPlayerId;
    const p = G.players.find(x=>x.id===pid);
    const isAI = !!p?.isAI;
    const selected = d.selectedId;

    const pickList = d.order.map(id=>{
      const pp = G.players.find(x=>x.id===id);
      const got = (d.picks[id]||[])[0];
      return `<div class="small ${id===pid?'':'muted'}">
        ${escapeHtml(pp?.name||id)}: ${got ? escapeHtml(got.name||'Upgrade') : '—'}
      </div>`;
    }).join('');

    return `
      <div class="row" style="justify-content:space-between">
        <div>
          <strong>Championship: Build Your Car</strong>
          <div class="small muted">Current picker: <strong>${escapeHtml(p?.name||'')}</strong> ${isAI?'(AI)':''}</div>
        </div>
        <div class="tag2">Pick 1</div>
      </div>

      <div class="grid2" style="margin-top:10px">
        <div>
          <div class="small muted">Market (click one)</div>
          <div class="market" style="margin-top:8px">
            ${d.market.map(c=>{
              const on = selected===c.id ? 'sel' : '';
              return `<button class="cardBtn ${on}" data-upg="${c.id}" title="${escapeHtml(fmtUpgradeCardShort(c))}">
                <div class="cardFace">
                  <div class="cardTitle">${escapeHtml(c.type==='upgrade' ? `U${c.upgNum} ${c.name}` : `U${c.upgNum||''} Heat`)}</div>
                  <div class="cardMid">${escapeHtml(upgradeCardFaceText(c))}</div>
                  <div class="cardBot">${escapeHtml(fmtUpgradeCardBottom(c))}</div>
                </div>
              </button>`;
            }).join('')}
          </div>

          <div class="row" style="margin-top:10px">
            <button class="btn primary" data-act="draftPick" ${(!selected||isAI)?'disabled':''}>Pick selected</button>
            <button class="btn" data-act="draftAuto" ${isAI?'':'disabled'}>AI pick</button>
          </div>

          <div class="note small" style="margin-top:10px">
            <div><strong>Optional swap (last picker only)</strong></div>
            <div class="muted">After all picks, the last picker may swap their chosen upgrade with one remaining in the market.</div>
          </div>
        </div>

        <div class="note">
          <div><strong>Draft order</strong></div>
          <div class="small muted">Worst overall picks first.</div>
          <div style="margin-top:6px">${pickList}</div>
        </div>
      </div>
    `;
  }

  function hookChampDraftUI(){
    const root = $('#rightPanel');
    const d = G.draft;
    if (!d) return;

    $$('.market .cardBtn', root).forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const id = btn.getAttribute('data-upg');
        d.selectedId = id;
        renderAll();
      });
    });

    const btnPick = $('[data-act="draftPick"]', root);
    if (btnPick) btnPick.addEventListener('click', ()=>{
      champDraftPickSelected();
    });

    const btnAuto = $('[data-act="draftAuto"]', root);
    if (btnAuto) btnAuto.addEventListener('click', ()=>{
      champDraftAIPick();
    });

    // Auto-pick for AI (debounced to avoid deep synchronous recursion)
    const pid = d.currentPlayerId;
    const p = G.players.find(x=>x.id===pid);
    if (p && p.isAI){
      if (!d._aiPicking){
        d._aiPicking = true;
        setTimeout(()=>{ d._aiPicking = false; champDraftAIPick(); }, 120);
      }
    }
}

  function champDraftPickSelected(){
    const d = G.draft;
    if (!d) return;
    const pid = d.currentPlayerId;
    const p = G.players.find(x=>x.id===pid);
    if (!p || p.isAI) return;
    const selId = d.selectedId;
    const card = d.market.find(c=>c.id===selId);
    if (!card){ toast('Select a card.'); return; }
    (d.picks[pid] ||= []).push(card);
    d.market = d.market.filter(c=>c.id!==selId);
    log(`${p.name} drafts ${card.name||'Upgrade'}.`);
    d.selectedId = null;
    champDraftAdvance();
  }

  function champDraftAIPick(){
    const d = G.draft;
    if (!d) return;
    const pid = d.currentPlayerId;
    const p = G.players.find(x=>x.id===pid);
    if (!p || !p.isAI) return;
    const choice = chooseUpgradeFromMarket(p, d.market);
    if (!choice){ toast('No market cards.'); return; }
    (d.picks[pid] ||= []).push(choice);
    d.market = d.market.filter(c=>c.id!==choice.id);
    log(`${p.name} drafts ${choice.name||'Upgrade'}.`);
    champDraftAdvance();
  }

  function champDraftAdvance(){
    const d = G.draft;
    if (!d) return;
    // next picker
    if (d.pickerIdx >= d.order.length-1){
      // all picked
      champDraftFinalize();
      return;
    }
    d.pickerIdx++;
    d.currentPlayerId = d.order[d.pickerIdx];
    renderAll();
    hookChampDraftUI();
  }

  function champDraftFinalize(){
    const d = G.draft;
    if (!d) return;

    // Last picker optional swap (human only for now; AI may choose to swap if better).
    const lastId = d.order[d.order.length-1];
    const lastP = G.players.find(x=>x.id===lastId);
    const picked = (d.picks[lastId]||[])[0];

    if (lastP && lastP.isAI && picked && d.market.length){
      // simple: swap if best market score > picked score
      const best = chooseUpgradeFromMarket(lastP, d.market);
      const cand = best;
      if (cand){
        // compare scores by heuristic: reuse chooser ordering
        const pool = [picked, cand].filter(Boolean);
        const top = chooseUpgradeFromMarket(lastP, pool);
        if (top && top.id !== picked.id){
          // swap
          d.market = d.market.filter(c=>c.id!==cand.id);
          d.market.push(picked);
          d.picks[lastId] = [cand];
          log(`${lastP.name} (AI) swaps to ${cand.name||'Upgrade'}.`);
        }
      }
    }

    // Apply picks to persistent upgrades
    for (const pid of d.order){
      const p = G.players.find(x=>x.id===pid);
      const c = (d.picks[pid]||[])[0];
      if (p && c){
        p.champ.upgrades.push(deepClone(c));
      }
    }

    // Return remaining market to upgrade deck
    if (d.market.length){
      for (const c of d.market) G.champ.upgradeUsed.push(deepClone(c));
    }
    G.draft = null;

    log('Build Your Car complete. Starting race setup...');
    champBuildRaceDecksAndStart();
  }

  function champAwardPointsForRace(){
    const pts = (G.champ?.points && G.champ.points.length) ? G.champ.points : CHAMP_DEFAULT_POINTS;
    const order = G.finishedOrder.slice();
    for (let i=0;i<order.length;i++){
      const pid = order[i];
      const p = G.players.find(x=>x.id===pid);
      if (!p) continue;
      const add = (i < pts.length) ? pts[i] : 0;
      p.champ.points += add;
      p.champ.lastFinish = i+1;
    }
  }

  function champStandings(){
    const arr = G.players.slice();
    arr.sort((a,b)=>{
      const ap=a.champ?.points||0, bp=b.champ?.points||0;
      if (bp!==ap) return bp-ap;
      const al=a.champ?.lastFinish||999, bl=b.champ?.lastFinish||999;
      return al-bl;
    });
    return arr;
  }

  function champNextRace(){
    if (!G.champ) return;
    champAwardPointsForRace();
    G.champ.raceIndex++;
    if (G.champ.raceIndex >= G.champ.racesTotal){
      log('Championship complete.');
      G.phase = PHASE.FINISHED;
      renderAll();
      return;
    }

    // Reset race state
    G.round = 1;
    G.resolveOrder = [];
    G.resolveIdx = 0;
    G.planningIdx = 0;
    G.finishedOrder = [];
    for (const p of G.players){
      p.finished = false;
      p.removedFromTrack = false;
      p.finishRank = null;
      p.lap = 0;
      p.gear = 1;
      p._resolvedThisRound = false;
      p._revealPrepared = false;
      p._revealProcessed = false;
      p._movedThisReveal = false;
    }

    // Load next track + press corners
    const presetId = G.champ.schedule[G.champ.raceIndex];
    const preset = getTrackPreset(presetId);
    setTrack(preset.track, {persist:false, presetId, remapPositions:false});
    champSetupPressCorners();

    // Starting grid based on standings (will be placed during deck build)
    log(`Race ${G.champ.raceIndex+1} begins on "${preset.name}".`);

    // Run Build Your Car draft again
    G.phase = PHASE.DRAFT;
    initChampBuildDraft();
    renderAll();
  }

function applyTrackBasics(){
    const spaces = parseInt($('#trkSpaces').value,10);
    const spots = parseInt($('#trkSpots').value,10);
    const finish = parseInt($('#trkFinish').value,10);
    const laps = parseInt($('#trkLaps').value,10);
    const start = parseInt($('#trkStart').value,10);
    const t = normalizeTrack({...G.track, spacesCount:spaces, spotsPerSpace:spots, finishIndex:finish, lapsRequired:laps, startGridStartIndex:start});
    // Re-clip corners into new range
    t.corners = (G.track.corners||[]).filter(c => c.cornerLineIndex < t.spacesCount);
    setTrack(t, {persist:true, presetId:(isUserPresetId(G.trackPresetId)?G.trackPresetId:'custom'), remapPositions:true});
  }

  function setSeedFromInput(){
    const s = ($('#seedInput').value||'').trim();
    if (!s){ toast('Seed cannot be empty.'); return; }
    G.seed = s;
    G.rngCalls = 0;
    rng = makeRng(G.seed, 0);
    log(`Seed set to ${G.seed}.`);
  }

  function addPlayer(isAI){
    if (G.players.length >= 6){ toast('Max 6 players.'); return; }
    pushHistory('Add player');
    const palette = ['#ff5b74','#5bd6ff','#7dff9b','#ffce5b','#b58cff','#ff8c5b'];
    const used = new Set(G.players.map(p=>p.color));
    const color = palette.find(c=>!used.has(c)) || '#5bd6ff';
    const name = isAI ? `AI ${G.players.length+1}` : `P${G.players.length+1}`;
    // temporary shell player (final decks built on start)
    G.players.push({
      id: uid('tmp'), name, color, isAI,
      gear: 1, engine: [], deck: [], discard: [], hand: [], play: [],
      boostUsed:false, pos:{idx:0,lane:0}, lap:0, finished:false, removedFromTrack:false, finishRank:null,
      planned:{gearTarget:1, payHeatForShift:false, cards:[], locked:false},
      publicTopDiscard:null
    });
    renderAll();
  }

  function randomizeStartingGrid(){
    const active = G.players;
    // Shuffle order
    const ids = active.map(p=>p.id);
    for (let i=ids.length-1;i>0;i--){
      const j = Math.floor(rng()*(i+1));
      [ids[i], ids[j]] = [ids[j], ids[i]];
    }
    const ordered = ids.map(id => active.find(p=>p.id===id));

    // Place one at a time filling spots in ascending order
    const t = G.track;
    const start = t.startGridStartIndex || 0;
    let cursor = start;
    let lane = 0;
    for (const p of ordered){
      p.pos.idx = cursor;
      p.pos.lane = lane;
      // advance lane then space
      if (t.spotsPerSpace === 2){
        lane = 1 - lane;
        if (lane === 0) cursor = (cursor + 1) % t.spacesCount;
      } else {
        cursor = (cursor + 1) % t.spacesCount;
      }
    }
    log('Starting grid randomized.');
  }

  function startRace(){
    if (G.players.length < 1){ toast('Add at least 1 player.'); return; }
    pushHistory('Start race');

    // Capture module toggles (in case user didn't trigger change event)
    const cbG = $('#modGarage'); if (cbG) G.modules.garage = !!cbG.checked;
    const cbW = $('#modWeather'); if (cbW) G.modules.weatherRoad = !!cbW.checked;
    const selU = $('#upgLevel'); if (selU) G.modules.upgradePool = selU.value;

    const cbC = $('#modChamp'); if (cbC) G.modules.championship = !!cbC.checked;
    // Championship overrides
    if (G.modules.championship){
      // Force advanced modules state
      G.modules.garage = false;
      G.modules.weatherRoad = true;
      // Capture config from inputs (best-effort)
      const heat = clamp(parseInt($('#cfgHeat').value||6,10), 0, 12);
      const stress = clamp(parseInt($('#cfgStress').value||3,10), 0, 8);
      startChampionshipFromSetup({heat, stress});
      return;
    }

    // Build player objects WITHOUT initial draw (so weather/draft can modify the deck first)
    const heat = clamp(parseInt($('#cfgHeat').value||6,10), 0, 12);
    const stress = clamp(parseInt($('#cfgStress').value||3,10), 0, 8);
    const built=[];
    for (const p0 of G.players){
      const p = makePlayer({
        name:p0.name,
        color:p0.color,
        isAI:p0.isAI,
        heatInEngine:heat,
        stressInDeck:stress,
        useStartingUpgrades: !G.modules.garage,
        drawStartHand:false
      });
      built.push(p);
    }
    G.players = built;
    G.startedCount = built.length;

    // Place grid (random order by default)
    randomizeStartingGrid();

    // Prepare weather/road before draft so players could (in real game) draft accordingly.
    initWeatherRoadIfEnabled();
    applyWeatherSetupToAllPlayers();

    // If Garage Draft enabled, run draft first.
    if (G.modules.garage){
      initGarageDraft();
      renderAll();
      return;
    }

    // Otherwise, proceed to planning.
    finalizeStartRaceIntoPlanning();
  }

  function drawStartingHands(){
    for (const p of G.players){
      p.hand = [];
      p.play = [];
      // Draw 7
      for (let i=0;i<7;i++){
        const c = drawFromDeck(p, {allowReshuffle:true});
        if (!c) break;
        p.hand.push(c);
      }
      p.publicTopDiscard = topOf(p.discard);
      p.boostUsed = false;
      p.planned = {gearTarget: p.gear || 1, payHeatForShift:false, cards: []};
    }
  }

  function finalizeStartRaceIntoPlanning(){
    // Starting hands after all setup modifications.
    drawStartingHands();

    G.phase = PHASE.PLANNING;
    G.planningIdx = 0;
    G.round = 1;
    G.finishedOrder = [];
    // clear per-round markers
    for (const p of G.players){ delete p._resolvedThisRound; }

    log(`Race started with ${G.players.length} car(s), ${G.track.lapsRequired} lap(s).`);
    renderAll();
    ensurePlanning();
  }

  function renderPlanningUI(p){
    if (!p) return '<div class="muted">—</div>';

    const playableCount = p.hand.filter(cardCanBePlayed).length;
    const selected = new Set(p.planned.cards);

    const handHtml = p.hand.map(c => {
      const disabled = (!cardCanBePlayed(c)) || (selected.size >= p.gear && !selected.has(c.id));
      const cls = ['card', disabled?'disabled':'', selected.has(c.id)?'selected':''].join(' ');
      return `
        <div class="${cls}" data-cid="${c.id}" title="${escapeHtml(cardTooltip(c))}">
          <div class="top"><div class="val">${c.type==='stress'?'+':(c.type==='heat'?'':(c.value??''))}</div><div class="tag">${c.type.toUpperCase()}</div></div>
          <div class="btm" style="flex-direction:column;align-items:flex-start;gap:2px">
            <div class="row" style="width:100%;justify-content:space-between">
              <div class="sym ${c.type==='stress'?'plus':(c.type==='heat'?'heat':((c.type==='upgrade'&&c.cool)?'cool':''))}">${c.type==='stress'?'+':(c.type==='heat'?'HEAT':(c.type==='upgrade'?(c.cool?('❄'+c.cool):''):''))}</div>
              <div class="small muted">${c.type==='upgrade'?(`U${c.upgNum||''}`):(c.type==='heat'&&c.origin==='upgrade'?(`U${c.upgNum||''}`):'')}</div>
            </div>
            ${c.type==='upgrade'?(`<div class="upgLabel">${escapeHtml(c.name||'Upgrade')}</div>`):(c.type==='heat'&&c.origin==='upgrade'?(`<div class="upgLabel">Upgrade Heat</div>`):'')}
          </div>
        </div>
      `;
    }).join('');

    const shiftOptions = [1,2,3,4].map(g => {
      const delta = g - p.gear;
      const needsHeat = Math.abs(delta) === 2;
      const label = needsHeat ? `${g} (pay 1 Heat)` : `${g}`;
      return `<option value="${g}" ${p.gear===g?'selected':''}>${label}</option>`;
    }).join('');

    return `
      <div class="note">
        <div class="row" style="justify-content:space-between">
          <div>
            <strong>${escapeHtml(p.name)}</strong> <span class="tag2" style="border-color:rgba(91,214,255,.35)">Planning</span>
            <div class="small muted">Choose gear (±1 free, ±2 costs 1 Heat from engine), then pick exactly ${p.gear} card(s) to play (no Heat cards).</div>
          </div>
          <button class="btn primary" id="btnLock">Lock In</button>
        </div>
        <div class="hr"></div>
        <div class="grid3">
          <div class="note" style="margin:0">
            <div class="small muted">Engine Heat</div>
            <div style="font-size:22px;font-weight:900">${p.engine.length}</div>
          </div>
          <div class="note" style="margin:0">
            <div class="small muted">Deck / Discard</div>
            <div style="font-size:14px"><span class="goodTxt">${p.deck.length}</span> / <span class="warn">${p.discard.length}</span></div>
            <div class="small muted">Top discard: ${escapeHtml(fmtCard(p.publicTopDiscard))}</div>
          </div>
          <div class="note" style="margin:0">
            <div class="small muted">Gear</div>
            <div class="row" style="justify-content:space-between">
              <select id="gearSel">${shiftOptions}</select>
              <span class="tag2">Play ${p.gear} card(s)</span>
            </div>
          </div>
        </div>

        <div class="hr"></div>
        <div class="row" style="justify-content:space-between">
          <div><strong>Hand</strong> <span class="small muted">(${p.hand.length} cards • playable ${playableCount})</span></div>
          <div class="pill">Selected: <span id="selCount">${selected.size}</span> / ${p.gear}</div>
        </div>
        <div class="hand" id="hand">${handHtml}</div>
        ${renderUpgradeDetailsFromHand(p.hand)}


      <div class="note small" style="margin-top:10px">
        <strong>Tip:</strong> Stress cards (+) will flip random speed 1–4 (Basic) during reveal. Heat cards clog your hand and can’t be played.
      </div>
    `;
  }

  function hookPlanningUI(p){
    if (!p) return;

    // Gear selection
    $('#gearSel').addEventListener('change', (e) => {
      const g = parseInt(e.target.value,10);
      pushHistory(`Shift gear (planning): ${p.name}`);
      const res = applyShift(p, g);
      if (!res.ok){ toast(res.reason); }
      else if (res.paid){ log(`${p.name} shifts 2 gears and pays 1 Heat.`); }
      renderAll();
    });

    // Card select
    const hand = $('#hand');
    hand.addEventListener('click', (e) => {
      const cardEl = e.target.closest('.card');
      if (!cardEl) return;
      const cid = cardEl.getAttribute('data-cid');
      const c = p.hand.find(x => x.id === cid);
      if (!c) return;
      if (!cardCanBePlayed(c)) return;

      const sel = new Set(p.planned.cards);
      if (sel.has(cid)) sel.delete(cid);
      else {
        if (sel.size >= p.gear) return;
        sel.add(cid);
      }
      p.planned.cards = Array.from(sel);
      $('#selCount').textContent = String(sel.size);
      renderAll();
    });

    // Lock
    $('#btnLock').addEventListener('click', () => nextStep());
  }

  function renderResolutionUI(p){
    if (!p) return '<div class="muted">—</div>';

    const step = G.activeStep;

    const summary = `
      <div class="grid3">
        <div class="note" style="margin:0">
          <div class="small muted">Position</div>
          <div style="font-size:16px"><strong>Space ${p.pos.idx}</strong> ${p.pos.lane===0?'(Race Line)':'(Outside)'}</div>
          <div class="small muted">Lap ${p.lap}/${G.track.lapsRequired}</div>
        </div>
        <div class="note" style="margin:0">
          <div class="small muted">Gear</div>
          <div style="font-size:22px;font-weight:900">${p.gear}</div>
          <div class="small muted">Cooldown cap this turn: ${cooldownCapacity(p)}</div>
        </div>
        <div class="note" style="margin:0">
          <div class="small muted">Engine Heat</div>
          <div style="font-size:22px;font-weight:900">${p.engine.length}</div>
          <div class="small muted">Boost used: ${p.boostUsed?'Yes':'No'}</div>
        </div>
      </div>
    `;

    const playArea = p.play.map(c => `<span class="tag2">${escapeHtml(fmtCard(c))}</span>`).join(' ');

    const handHtml = p.hand.map(c => {
      const cls = ['card', (ensureDiscardPickSet().has(c.id)?'selected':'')].join(' ');
      const disabled = (step === STEP.DISCARD) ? isNonDiscardable(c) : !cardCanBePlayed(c);
      return `
        <div class="${cls} ${disabled?'disabled':''}" data-cid="${c.id}" title="${escapeHtml(cardTooltip(c))}">
          <div class="top"><div class="val">${c.type==='stress'?'+':(c.type==='heat'?'':(c.value??''))}</div><div class="tag">${c.type.toUpperCase()}</div></div>
          <div class="btm" style="flex-direction:column;align-items:flex-start;gap:2px">
            <div class="row" style="width:100%;justify-content:space-between">
              <div class="sym ${c.type==='stress'?'plus':(c.type==='heat'?'heat':((c.type==='upgrade'&&c.cool)?'cool':''))}">${c.type==='stress'?'+':(c.type==='heat'?'HEAT':(c.type==='upgrade'?(c.cool?('❄'+c.cool):''):''))}</div>
              <div class="small muted">${c.type==='upgrade'?(`U${c.upgNum||''}`):(c.type==='heat'&&c.origin==='upgrade'?(`U${c.upgNum||''}`):'')}</div>
            </div>
            ${c.type==='upgrade'?(`<div class="upgLabel">${escapeHtml(c.name||'Upgrade')}</div>`):(c.type==='heat'&&c.origin==='upgrade'?(`<div class="upgLabel">Upgrade Heat</div>`):'')}
          </div>
        </div>
      `;
    }).join('');

    // Step-specific controls
    let controls = '';

        if (step === STEP.REVEAL_MOVE){
      const pc = G.pendingChoice;
      const needsBrake = (pc && pc.kind==='brake' && pc.pid===p.id);
      controls = `
        <div class="note">
          <div class="row" style="justify-content:space-between;align-items:flex-start">
            <div>
              <strong>Step 3: Reveal & Move</strong>
              <div class="small muted">Reveal played cards. First total fixed Speed, resolve Stress/+ boost symbols, then choose any variable Speed (Brakes), then move exactly total Speed.</div>
              ${needsBrake ? `
                <div class="hr"></div>
                <div>
                  <div class="pill">Brakes</div>
                  <div class="small muted" style="margin-top:6px">Choose Speed for <strong>${escapeHtml(pc.label)}</strong>:</div><div class="small muted" style="margin-top:4px">Subtotal after Stress/+ boosts: <strong>${pc.baseSpeed}</strong></div>
                  <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">
                    ${pc.choices.map(v=>`<button class=\"btn\" data-act=\"brakeChoice\" data-val=\"${v}\">${v} <span class=\"muted\">(→ ${pc.baseSpeed + v})</span></button>`).join('')}
                  </div>
                </div>
              `:''}
            </div>
            <button class="btn primary" id="btnNext" ${needsBrake?'disabled':''}>Reveal & Move</button>
          </div>
        </div>
      `;
    }

    if (step === STEP.ADRENALINE){
      const eligible = G.adrenaline.eligible;
      controls = `
        <div class="note">
          <div class="row" style="justify-content:space-between">
            <div>
              <strong>Step 4: Adrenaline</strong>
              <div class="small muted">Only if you are the last car to move this round (or one of last two with 5+ cars). Choose optional bonuses for this turn only.</div>
            </div>
            <button class="btn primary" id="btnNext">Continue</button>
          </div>
          <div class="hr"></div>
          ${eligible ? `
            <div class="row">
              <label class="row small"><input type="checkbox" id="adrenMove" ${G.adrenaline.move?'checked':''} /> +1 Speed & Move 1</label>
              <label class="row small"><input type="checkbox" id="adrenCool" ${G.adrenaline.cooldownBonus?'checked':''} /> +1 Cooldown</label>
              <span class="pill">Eligible</span>
            </div>
          ` : `
            <div class="row"><span class="pill">Not eligible</span></div>
          `}
        </div>
      `;
    }

    if (step === STEP.REACT){
  if (!p._reactActions) buildReactActions(p);
  const a = currentReactAction(p);
  const pending = !!a;
  const cap = cooldownCapacity(p);
  const heatInHand = p.hand.filter(c=>c.type==='heat').length;
  const stressInHand = p.hand.filter(c=>c.type==='stress').length;
  const canBoost = (!p.boostUsed && p.engine.length>0);
  const finishDisabled = pending ? 'disabled' : '';
  const actionUI = !a ? `
    <div class="row"><span class="pill good">All upgrade effects resolved</span></div>
  ` : (() => {
    const cardLabel = escapeHtml(a.cardLabel);
    if (a.type==='scrap'){
      return `
        <div class="pill">Upgrade</div>
        <div class="small" style="margin-top:6px"><strong>${cardLabel}</strong></div>
        <div class="small muted" style="margin-top:4px">Scrap ${a.val}: discard that many cards from the top of your draw deck.</div>
        <div class="row" style="margin-top:10px;gap:8px;flex-wrap:wrap">
          <button class="btn good" id="btnActApply">Resolve Scrap</button>
          <button class="btn" id="btnActSkip">Skip</button>
        </div>
      `;
    }
    if (a.type==='upgCooldown'){
      const max = Math.min(a.val, heatInHand);
      return `
        <div class="pill">Upgrade</div>
        <div class="small" style="margin-top:6px"><strong>${cardLabel}</strong></div>
        <div class="small muted" style="margin-top:4px">Cooldown ${a.val}: return up to ${a.val} Heat from hand → engine.</div>
        <div class="row" style="margin-top:10px;gap:8px;flex-wrap:wrap;align-items:center">
          <input class="input" style="width:90px" id="actNum" type="number" min="0" max="${max}" value="${max}" />
          <button class="btn good" id="btnActApply" ${max===0?'disabled':''}>Apply</button>
          <button class="btn" id="btnActSkip">Skip</button>
        </div>
      `;
    }
    if (a.type==='reduceStress'){
      const max = Math.min(a.val, stressInHand);
      return `
        <div class="pill">Upgrade</div>
        <div class="small" style="margin-top:6px"><strong>${cardLabel}</strong></div>
        <div class="small muted" style="margin-top:4px">Reduce Stress ${a.val}: discard up to ${a.val} Stress card(s) from your hand.</div>
        <div class="row" style="margin-top:10px;gap:8px;flex-wrap:wrap;align-items:center">
          <input class="input" style="width:90px" id="actNum" type="number" min="0" max="${max}" value="${max}" />
          <button class="btn good" id="btnActApply" ${max===0?'disabled':''}>Apply</button>
          <button class="btn" id="btnActSkip">Skip</button>
        </div>
      `;
    }
    if (a.type==='salvage'){
      // Rules: you may look through your discard pile and choose up to # cards there.
      // Show the full discard pile (most recent first) for accurate Salvage choices.
      const list = p.discard.slice().reverse();
      const max = a.val;
      return `
        <div class="pill">Upgrade</div>
        <div class="small" style="margin-top:6px"><strong>${cardLabel}</strong></div>
        <div class="small muted" style="margin-top:4px">Salvage ${a.val}: choose up to ${a.val} card(s) from your discard to shuffle into your draw deck.</div>
        <div class="small muted" style="margin-top:6px">Discard pile (most recent first):</div>
        <div class="note" style="margin-top:8px;max-height:220px;overflow:auto">
          ${list.length?list.map(c=>`<label class="row small" style="gap:8px"><input type="checkbox" class="actPick" value="${c.id}"> ${escapeHtml(fmtCard(c))}</label>`).join(''):`<div class="small muted">Discard is empty.</div>`}
        </div>
        <div class="row" style="margin-top:10px;gap:8px;flex-wrap:wrap">
          <button class="btn good" id="btnActApply" ${p.discard.length?'' :'disabled'}>Apply</button>
          <button class="btn" id="btnActSkip">Skip</button>
          <span class="pill">Pick ≤ ${max}</span>
        </div>
      `;
    }
    if (a.type==='limitMod'){
      return `
        <div class="pill">Upgrade</div>
        <div class="small" style="margin-top:6px"><strong>${cardLabel}</strong></div>
        <div class="small muted" style="margin-top:4px">Corner limit ${a.val>0?'+':'−'}${Math.abs(a.val)} for you this turn (applies to corner checks this round).</div>
        <div class="row" style="margin-top:10px;gap:8px;flex-wrap:wrap">
          <button class="btn good" id="btnActApply">Apply</button>
          <button class="btn" id="btnActSkip">Skip</button>
        </div>
      `;
    }
    if (a.type==='slipBonus'){
      return `
        <div class="pill">Upgrade</div>
        <div class="small" style="margin-top:6px"><strong>${cardLabel}</strong></div>
        <div class="small muted" style="margin-top:4px">Slipstream +${a.val} for you this turn (adds to the normal +2).</div>
        <div class="row" style="margin-top:10px;gap:8px;flex-wrap:wrap">
          <button class="btn good" id="btnActApply">Apply</button>
          <button class="btn" id="btnActSkip">Skip</button>
        </div>
      `;
    }
    if (a.type==='refresh'){
      return `
        <div class="pill">Upgrade</div>
        <div class="small" style="margin-top:6px"><strong>${cardLabel}</strong></div>
        <div class="small muted" style="margin-top:4px">Refresh: place this Upgrade on top of your draw deck during Replenish instead of discarding it.</div>
        <div class="row" style="margin-top:10px;gap:8px;flex-wrap:wrap">
          <button class="btn good" id="btnActApply">Refresh</button>
          <button class="btn" id="btnActSkip">Skip</button>
        </div>
      `;
    }
    if (a.type==='accelerate'){
      return `
        <div class="pill">Upgrade</div>
        <div class="small" style="margin-top:6px"><strong>${cardLabel}</strong></div>
        <div class="small muted" style="margin-top:4px">Accelerate: gain +1 speed for each symbol you've used this turn (approx.). This increases corner speed.</div>
        <div class="row" style="margin-top:10px;gap:8px;flex-wrap:wrap">
          <button class="btn good" id="btnActApply">Accelerate</button>
          <button class="btn" id="btnActSkip">Skip</button>
        </div>
      `;
    }
    return `<div class="small muted">Unknown upgrade effect.</div>`;
  })();

  controls = `
    <div class="note">
      <div class="row" style="justify-content:space-between;align-items:flex-start">
        <div>
          <strong>Step 5: React</strong>
          <div class="small muted">Resolve upgrade symbols one-by-one, then you can finish React. (Gear cooldown and Boost are also available.)</div>
        </div>
        <button class="btn primary" id="btnNext" ${finishDisabled}>Finish React</button>
      </div>
      <div class="hr"></div>

      <div class="grid2">
        <div class="note" style="margin:0">
          <div class="row" style="justify-content:space-between">
            <div>
              <strong>Gear Cooldown</strong>
              <div class="small muted">Cap: ${cap} • Heat in hand: ${heatInHand}</div>
            </div>
            <button class="btn small" id="btnCooldown" ${cap===0||heatInHand===0?'disabled':''}>Use</button>
          </div>
          <div class="small muted">Returns Heat from hand → engine.</div>
        </div>
        <div class="note" style="margin:0">
          <div class="row" style="justify-content:space-between">
            <div>
              <strong>Boost</strong>
              <div class="small muted">Pay 1 Heat → flip until Basic, move that many.</div>
            </div>
            <button class="btn small" id="btnBoost" ${!canBoost?'disabled':''}>Boost</button>
          </div>
          <div class="small muted">Boost increases corner speed value.</div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="note" style="margin:0">
        <div class="row" style="justify-content:space-between;align-items:flex-start">
          <div>
            <strong>Upgrade Effects</strong>
            <div class="small muted">Pending: ${pending ? 'Yes' : 'No'} • Queue: ${(p._reactActions||[]).length ? (p._reactActionIdx+1)+' / '+(p._reactActions||[]).length : '0'}</div>
          </div>
          <span class="pill">${pending ? 'Resolve next' : 'Done'}</span>
        </div>
        <div class="hr"></div>
        ${actionUI}
      </div>

      <div class="hr"></div>
      <div class="small muted">Corner-speed value: <strong>${G.speedForCorner}</strong>. Corners crossed: ${(G.cornerCrossed||[]).map(c=>`@${c.cornerLineIndex}≤${c.speedLimit}`).join(', ')||'none'}.</div>
      <div class="small muted">If you crossed final finish this turn, Slipstream is not allowed.</div>
    </div>
  `;
}

if (step === STEP.SLIPSTREAM){
      const eligible = slipEligible(p);
      controls = `
        <div class="note">
          <div class="row" style="justify-content:space-between">
            <div>
              <strong>Step 6: Slipstream</strong>
              <div class="small muted">Optional if you are next to or behind another car. Move +2 spaces (does NOT increase corner speed). Cannot cross finish line.</div>
            </div>
            <button class="btn primary" id="btnNext">Continue</button>
          </div>
          <div class="hr"></div>
          <div class="row">
            ${eligible ? `
              <button class="btn good" id="btnSlip">Slipstream +2</button>
              <button class="btn" id="btnNoSlip">Skip</button>
              <span class="pill">Eligible</span>
            ` : `
              <span class="pill">Not eligible</span>
            `}
          </div>
        </div>
      `;
    }

    if (step === STEP.CHECK_CORNER){
      controls = `
        <div class="note">
          <div class="row" style="justify-content:space-between">
            <div>
              <strong>Step 7: Check Corner</strong>
              <div class="small muted">If you crossed a corner line, compare total Speed value (including Boost and Adrenaline +1, excluding Slipstream). Pay Heat or spin out.</div>
            </div>
            <button class="btn primary" id="btnNext">Resolve Corner</button>
          </div>
          <div class="hr"></div>
          <div class="small muted">Corner-speed value: <strong>${G.speedForCorner}</strong>. Crossed: ${(G.cornerCrossed||[]).map(c=>`@${c.cornerLineIndex}≤${c.speedLimit}`).join(', ')||'none'}.</div>
        </div>
      `;
    }

    if (step === STEP.DISCARD){
      controls = `
        <div class="note">
          <div class="row" style="justify-content:space-between">
            <div>
              <strong>Step 8: Discard (optional)</strong>
              <div class="small muted">You may discard any number of cards from hand, but you can never choose to discard Heat or Stress cards.</div>
            </div>
            <div class="row">
              <button class="btn" id="btnSkipDiscard">Skip</button>
              <button class="btn good" id="btnConfirmDiscard">Confirm Discard</button>
            </div>
          </div>
          <div class="small muted" style="margin-top:8px">Click cards to toggle discard selection (Heat/Stress disabled).</div>
        </div>
      `;
    }

    if (step === STEP.REPLENISH){
      controls = `
        <div class="note">
          <div class="row" style="justify-content:space-between">
            <div>
              <strong>Step 9: Replenish Hand</strong>
              <div class="small muted">Move play area to discard, then draw back up to 7. If deck runs out, shuffle discard into new deck (play area is not shuffled in until discarded).</div>
            </div>
            <button class="btn primary" id="btnNext">Replenish</button>
          </div>
        </div>
      `;
    }

    if (step === STEP.DONE){
      controls = `
        <div class="note">
          <div class="row" style="justify-content:space-between">
            <div>
              <strong>Turn Complete</strong>
              <div class="small muted">Proceed to next car in resolution order.</div>
            </div>
            <button class="btn primary" id="btnNext">Next Car</button>
          </div>
        </div>
      `;
    }

    const playedInfo = p.play.length ? `
      <div class="note small" style="margin-top:10px">
        <strong>Play Area:</strong> ${playArea || '—'}
      </div>
    ` : '';

    const finishBanner = p.finished ? `
      <div class="note" style="border-color:rgba(125,255,155,.35);background:rgba(125,255,155,.08)">
        <strong class="goodTxt">Finished!</strong> Rank so far: ${p.finishRank}
      </div>
    ` : '';

    return `
      ${finishBanner}
      ${summary}
      ${controls}
      ${playedInfo}

      <div class="hr"></div>

      <div class="row" style="justify-content:space-between">
        <div><strong>Hand</strong> <span class="small muted">(${p.hand.length})</span></div>
        <div class="small muted">Deck ${p.deck.length} • Discard ${p.discard.length} • Top discard: ${escapeHtml(fmtCard(p.publicTopDiscard))}</div>
      </div>
      <div class="hand" id="hand">${handHtml}</div>
        ${renderUpgradeDetailsFromHand(p ? p.hand : [])}

      <div class="note small" style="margin-top:10px">
        <strong>Resolution order:</strong> ${sortedCars(true,false).map(x => x.id===p.id?`<span class="tag2" style="border-color:rgba(91,214,255,.45)">${escapeHtml(x.name)}</span>`:`<span class="tag2">${escapeHtml(x.name)}</span>`).join(' ')}
      </div>
    `;
  }

  function hookResolutionUI(p){
    if (!p) return;

    const nextBtn = $('#btnNext');
    if (nextBtn) nextBtn.addEventListener('click', () => nextStep());

    // Brakes choice during Reveal & Move
    if (G.activeStep === STEP.REVEAL_MOVE){
      const pc = G.pendingChoice;
      if (pc && pc.kind==='brake' && pc.pid===p.id){
        $$('[data-act="brakeChoice"]').forEach(btn=>{
          btn.addEventListener('click', ()=>{
            const val = parseInt(btn.getAttribute('data-val'), 10);
            const card = p.play.find(c=>c && c.id===pc.cardId);
            if (card){
              pushHistory(`Choose Brakes speed: ${p.name} → ${val}`);
              card.chosen = val;
            }
            G.pendingChoice = null;
            renderAll();
            nextStep();
          });
        });
      }
    }

    // Adrenaline toggles
    if (G.activeStep === STEP.ADRENALINE && G.adrenaline.eligible && !p.isAI){
      const m = $('#adrenMove');
      const c = $('#adrenCool');
      if (m) m.addEventListener('change', () => { G.adrenaline.move = !!m.checked; });
      if (c) c.addEventListener('change', () => { G.adrenaline.cooldownBonus = c.checked ? 1 : 0; });
    }// React buttons
if (G.activeStep === STEP.REACT){
  // Ensure queue exists for humans too
  if (!p._reactActions) buildReactActions(p);

  const cd = $('#btnCooldown');
  const bs = $('#btnBoost');
  const applyBtn = $('#btnActApply');
  const skipBtn = $('#btnActSkip');

  if (cd) cd.addEventListener('click', () => {
    pushHistory(`Gear Cooldown: ${p.name}`);
    doCooldown(p, cooldownCapacity(p));
    renderAll();
  });

  if (bs) bs.addEventListener('click', () => {
    pushHistory(`Boost: ${p.name}`);
    const res = doBoost(p);
    if (!res.ok) toast(res.reason);
    renderAll();
  });

  if (applyBtn) applyBtn.addEventListener('click', () => {
    const a = currentReactAction(p);
    if (!a) return;
    pushHistory(`Upgrade effect: ${p.name} ${a.cardLabel} (${a.type})`);
    const card = p.play.find(x=>x && x.id===a.cardId);

    if (a.type==='scrap'){
      resolveScrap(p, a.val);
      p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
    } else if (a.type==='upgCooldown'){
      const max = Math.min(a.val, p.hand.filter(c=>c.type==='heat').length);
      const inp = $('#actNum');
      let n = inp ? parseInt(inp.value||'0',10) : max;
      n = clamp(isNaN(n)?max:n, 0, max);
      const moved = doCooldown(p, n, a.val);
      if (moved>0) p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
    } else if (a.type==='reduceStress'){
      const max = Math.min(a.val, p.hand.filter(c=>c.type==='stress').length);
      const inp = $('#actNum');
      let n = inp ? parseInt(inp.value||'0',10) : max;
      n = clamp(isNaN(n)?max:n, 0, max);
      const moved = resolveReduceStress(p, n);
      if (moved>0) p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
    } else if (a.type==='salvage'){
      const picks = $$('.actPick').filter(x=>x.checked).map(x=>x.value);
      if (picks.length > a.val){
        toast(`Pick at most ${a.val} card(s).`);
        return;
      }
      const moved = resolveSalvage(p, picks);
      if (moved>0) p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
    } else if (a.type==='limitMod'){
      if ((G.cornerCrossed||[]).length){
        p._turnLimitMod = (p._turnLimitMod||0) + a.val;
        p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
        log(`${p.name} applies ${a.cardLabel}: corner limit ${a.val>0?'+':'−'}${Math.abs(a.val)} this turn.`);
      } else {
        log(`${p.name} applies ${a.cardLabel}, but no corners were crossed this turn.`);
      }
    } else if (a.type==='slipBonus'){
      p._turnSlipBonus = (p._turnSlipBonus||0) + a.val;
      p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
      log(`${p.name} applies ${a.cardLabel}: Slipstream +${a.val} this turn.`);
    } else if (a.type==='refresh'){
      if (card){ card._refreshChosen = true; }
      p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
      log(`${p.name} sets ${a.cardLabel} to refresh (topdeck) at Replenish.`);
    } else if (a.type==='accelerate'){
      applyAccelerate(p);
      p._symbolsAppliedCount = (p._symbolsAppliedCount||0) + 1;
    }

    advanceReactAction(p);
    renderAll();
  });

  // Salvage UX: prevent selecting more than allowed by disabling extra checkboxes.
  const aNow = currentReactAction(p);
  if (aNow && aNow.type==='salvage'){
    const maxPick = aNow.val|0;
    const refreshPickLimits = () => {
      const picks = $$('.actPick');
      const selected = picks.filter(x=>x.checked).length;
      const lock = selected >= maxPick;
      picks.forEach(cb => {
        if (!cb.checked) cb.disabled = lock;
      });
    };
    $$('.actPick').forEach(cb => cb.addEventListener('change', refreshPickLimits));
    refreshPickLimits();
  }

  if (skipBtn) skipBtn.addEventListener('click', () => {
    const a = currentReactAction(p);
    if (!a) return;
    pushHistory(`Skip upgrade effect: ${p.name} ${a.cardLabel} (${a.type})`);
    log(`${p.name} skips ${a.cardLabel} (${a.type}).`);
    advanceReactAction(p);
    renderAll();
  });

  // React pending ends only when user clicks Finish React (and queue is done)
  G._reactPending = false;
}

    // Slipstream buttons
    if (G.activeStep === STEP.SLIPSTREAM){
      const slip = $('#btnSlip');
      const noslip = $('#btnNoSlip');
      if (slip) slip.addEventListener('click', () => {
        pushHistory(`Slipstream: ${p.name}`);
        doSlipstream(p, true);
        G._slipPending = false;
        renderAll();
      });
      if (noslip) noslip.addEventListener('click', () => {
        pushHistory(`Skip slipstream: ${p.name}`);
        doSlipstream(p, false);
        G._slipPending = false;
        renderAll();
      });
      // if not eligible, auto clear
      if (!slipEligible(p)) G._slipPending = false;
    }

    // Discard interactions
    if (G.activeStep === STEP.DISCARD){
      ensureDiscardPickSet();
      const hand = $('#hand');
      hand.addEventListener('click', (e) => {
        const cardEl = e.target.closest('.card');
        if (!cardEl) return;
        const cid = cardEl.getAttribute('data-cid');
        const c = p.hand.find(x => x.id === cid);
        if (!c || isNonDiscardable(c)) return;
        const dp = ensureDiscardPickSet();
        if (dp.has(cid)) dp.delete(cid);
        else dp.add(cid);
        renderAll();
      });

      $('#btnConfirmDiscard').addEventListener('click', () => {
        pushHistory(`Discard chosen: ${p.name}`);
        confirmDiscard(p, Array.from(ensureDiscardPickSet()));
        G._discardPick = new Set();
        renderAll();
      });
      $('#btnSkipDiscard').addEventListener('click', () => {
        pushHistory(`Skip discard: ${p.name}`);
        confirmDiscard(p, []);
        G._discardPick = new Set();
        renderAll();
      });

      G._discardPending = true;
    }

    // Let AI auto-advance when appropriate
    autoResolveAIIfNeeded();
  }

  function renderFinishedUI(){
    const order = G.finishedOrder.map((id, idx) => {
      const p = G.players.find(x => x.id === id);
      return `<li><strong>#${idx+1}</strong> ${escapeHtml(p?.name||'?')}</li>`;
    }).join('');

    let champBlock = '';
    if (G.modules.championship && G.champ){
      const rows = champStandings().map((p, i)=>{
        const pts = p.champ?.points||0;
        return `<tr><td>${i+1}</td><td>${escapeHtml(p.name)}</td><td>${pts}</td></tr>`;
      }).join('');
      champBlock = `
        <div class="note">
          <div class="row" style="justify-content:space-between">
            <strong>Championship Standings</strong>
            <span class="tag2">Race ${G.champ.raceIndex+1}/${G.champ.racesTotal}</span>
          </div>
          <table class="tbl" style="margin-top:8px">
            <thead><tr><th>#</th><th>Driver</th><th>Pts</th></tr></thead>
            <tbody>${rows}</tbody>
          </table>
          <div class="row" style="margin-top:10px">
            <button class="btn primary" id="btnNextRace">${(G.champ.raceIndex+1 < G.champ.racesTotal) ? 'Next Race' : 'Finish Championship'}</button>
          </div>
          <div class="small muted" style="margin-top:6px">Points are awarded when you click “Next Race”.</div>
        </div>
      `;
    }

    const hall = `
      <div class="note">
        <strong>Finish Order (this race)</strong>
        <ol>${order || '<li class="muted">—</li>'}</ol>
      </div>
    `;

    return `
      ${champBlock}
      ${hall}
      <div class="row">
        <button class="btn primary" id="btnRestart">Restart (keep track)</button>
        <button class="btn" id="btnBackSetup">Back to Setup</button>
      </div>
    `;
  }

  function hookFinishedUI(){

    const btnNext = $('#btnNextRace');
    if (btnNext){
      btnNext.addEventListener('click', ()=>{
        pushHistory('Next Race');
        champNextRace();
      });
    }
    $('#btnRestart').addEventListener('click', () => {
      pushHistory('Restart');
      // Restart with same players & track
      const cfgPlayers = G.players.map(p => ({name:p.name, color:p.color, isAI:p.isAI}));
      const seed = G.seed;
      const track = deepClone(G.track);
      newGame();
      G.seed = seed;
      G.track = track;
      rng = makeRng(G.seed, 0);
      // Add shells
      G.players = cfgPlayers.map(x => ({
        id: uid('tmp'), name:x.name, color:x.color, isAI:x.isAI,
        gear:1, engine:[], deck:[], discard:[], hand:[], play:[],
        boostUsed:false, pos:{idx:0,lane:0}, lap:0, finished:false, removedFromTrack:false, finishRank:null,
        planned:{gearTarget:1, payHeatForShift:false, cards:[], locked:false},
        publicTopDiscard:null
      }));
      renderAll();
    });
    $('#btnBackSetup').addEventListener('click', () => {
      pushHistory('Back to setup');
      // Convert to setup shells
      const cfgPlayers = G.players.map(p => ({name:p.name, color:p.color, isAI:p.isAI}));
      const seed = G.seed;
      const track = deepClone(G.track);
      newGame();
      G.seed = seed;
      G.track = track;
      rng = makeRng(G.seed, 0);
      G.players = cfgPlayers.map(x => ({
        id: uid('tmp'), name:x.name, color:x.color, isAI:x.isAI,
        gear:1, engine:[], deck:[], discard:[], hand:[], play:[],
        boostUsed:false, pos:{idx:0,lane:0}, lap:0, finished:false, removedFromTrack:false, finishRank:null,
        planned:{gearTarget:1, payHeatForShift:false, cards:[], locked:false},
        publicTopDiscard:null
      }));
      renderAll();
    });
  }

  function renderAll(){
    renderTrack();
    renderRight();
    rebuildLog();
    updateUndoBtn();
    maybeAutoScroll();
  }

  function maybeAutoScroll(){
    if ($('#autoScroll').value !== 'on') return;
    // Center on active player (planning/resolution)
    let p=null;
    if (G.phase === PHASE.PLANNING) p = G.players[G.planningIdx];
    if (G.phase === PHASE.RESOLUTION) p = activePlayer();
    if (!p) return;
    centerOnSpace(p.pos.idx);
  }

  function centerOnSpace(idx){
    const view = $('#trackView');
    const space = $(`#trackGrid .space:nth-child(${idx+1})`);
    if (!space) return;
    const rect = space.getBoundingClientRect();
    const vrect = view.getBoundingClientRect();
    const left = space.offsetLeft - (vrect.width/2) + (rect.width/2);
    view.scrollTo({left, behavior:'smooth'});
  }

  /***********************
   * Track Editor modal
   ***********************/
  function openTrackEditor(){
    const t = deepClone(G.track);
    openModal('Track Editor', `
      <div class="note">
        <strong>Schema</strong>
        <div class="small muted">Edit JSON then Apply. Values are validated. This simulator uses a linear circular track with a finish index and corner lines.</div>
        <div class="hr"></div>
        <textarea id="trkJson" class="kbd">${escapeHtml(JSON.stringify(t, null, 2))}</textarea>
        <div class="row" style="margin-top:10px">
          <button class="btn primary" id="btnApplyTrack">Apply</button>
          <button class="btn" id="btnExportTrack">Export JSON</button>
          <span class="small muted">Tip: corners are {cornerLineIndex, speedLimit}</span>
        </div>
      </div>
      <div class="note small" style="margin-top:10px">
        <strong>Note:</strong> If you apply a new spacesCount mid-race, cars may be remapped mod N.
      </div>
    `);

    $('#btnApplyTrack').addEventListener('click', () => {
      const raw = $('#trkJson').value;
      try{
        const obj = JSON.parse(raw);
        pushHistory('Apply track editor');
        setTrack(obj, {persist:true, presetId:(isUserPresetId(G.trackPresetId)?G.trackPresetId:'custom'), remapPositions:true});
        closeModal();
        renderAll();
      } catch(e){
        toast('Invalid JSON: ' + e.message);
      }
    });

    $('#btnExportTrack').addEventListener('click', () => {
      const raw = $('#trkJson').value;
      try{
        const obj = JSON.parse(raw);
        const nt = normalizeTrack(obj);
        downloadText('track.json', JSON.stringify(nt, null, 2), 'application/json');
      } catch(e){
        toast('Invalid JSON.');
      }
    });
  }

  /***********************
   * Help modal
   ***********************/
  function openHelp(){
    openModal('Help', `
      <div class="note">
        <strong>What this is</strong>
        <div class="small muted">An offline, single-file web simulator implementing the <em>core rules</em> of Heat: Pedal to the Metal (no official art/assets). Hotseat play with optional simple AI.</div>
      </div>
      <div class="hr"></div>
      <div class="note">
        <strong>Flow per round</strong>
        <ol class="small muted">
          <li><strong>Planning:</strong> each player shifts gear (±1 free, ±2 pay 1 Heat from engine) and selects exactly <strong>gear</strong> cards (no Heat).</li>
          <li><strong>Resolution (front to back):</strong> Reveal & Move → Adrenaline (last car(s)) → React (Cooldown/Boost) → Slipstream → Check Corner → Discard → Replenish.</li>
        </ol>
      </div>
      <div class="note small" style="margin-top:10px">
        <strong>Symbols</strong>
        <ul class="small muted">
          <li><strong>Stress (+):</strong> when played, flip until a Basic card (1–4); non-basic flipped cards are discarded.</li>
          <li><strong>Cooldown:</strong> in Gear 1 = 3, Gear 2 = 1 (plus Adrenaline +1). Move Heat from hand → engine.</li>
          <li><strong>Boost:</strong> pay 1 Heat from engine; flip until Basic; move that many; increases corner speed value; once per turn.</li>
          <li><strong>Slipstream:</strong> optional if next to or behind a car; move +2; doesn’t increase corner speed; cannot cross finish.</li>
        </ul>
      </div>
      <div class="note small" style="margin-top:10px">
        <strong>Save/Load</strong> keeps full state + seed + RNG call count for deterministic playback.
      </div>
    `);
  }

  /***********************
   * Modal helpers
   ***********************/
  function openModal(title, bodyHtml, sub=null){
    $('#modalTitle').textContent = title;
    const subEl = $('#modalSub');
    if (sub){ subEl.style.display='inline-block'; subEl.textContent=sub; }
    else subEl.style.display='none';
    $('#modalBody').innerHTML = bodyHtml;
    $('#modalBack').classList.add('show');
    $('#modalBack').setAttribute('aria-hidden','false');
  }
  function closeModal(){
    $('#modalBack').classList.remove('show');
    $('#modalBack').setAttribute('aria-hidden','true');
    $('#modalBody').innerHTML = '';
  }

  /***********************
   * Toast
   ***********************/
  let toastTimer=null;
  function toast(msg){
    clearTimeout(toastTimer);
    const pill = $('#phasePill');
    const old = pill.textContent;
    pill.textContent = msg;
    pill.style.borderColor = 'rgba(255,206,91,.45)';
    pill.style.background = 'rgba(255,206,91,.10)';
    toastTimer = setTimeout(() => {
      pill.style.borderColor='';
      pill.style.background='';
      pill.textContent = old;
    }, 1800);
  }

  /***********************
   * Save/Load
   ***********************/
  function saveGame(){
    const payload = {
      type: 'heat-core-sim-save',
      savedAt: new Date().toISOString(),
      game: G
    };
    downloadText('heat_core_sim_save.json', JSON.stringify(payload, null, 2), 'application/json');
  }

  function loadGameFromFile(file){
    const reader = new FileReader();
    reader.onload = () => {
      try{
        const obj = JSON.parse(reader.result);
        if (obj.type !== 'heat-core-sim-save') throw new Error('Not a Heat core sim save file.');
        pushHistory('Load game');
        G = obj.game;
        // Normalize + persist track just in case
        setTrack(G.track, {persist:true, presetId:(G.trackPresetId||'custom'), remapPositions:false});
        rng = makeRng(G.seed, G.rngCalls||0);
        renderAll();
        log('Game loaded.');
      } catch(e){
        toast('Load failed: ' + e.message);
      }
    };
    reader.readAsText(file);
  }

  /***********************
   * Header hooks
   ***********************/
  function hookHeader(){
    $('#btnUndo').addEventListener('click', undo);
    $('#btnSave').addEventListener('click', () => { pushHistory('Save'); saveGame(); });
    $('#fileLoad').addEventListener('change', (e) => {
      const f = e.target.files[0];
      if (f) loadGameFromFile(f);
      e.target.value = '';
    });
    $('#btnNew').addEventListener('click', () => {
      if (!confirm('Start a new game? Current state will be lost unless you saved.')) return;
      newGame();
    });
    $('#btnTrackEditor').addEventListener('click', openTrackEditor);
    $('#btnHelp').addEventListener('click', openHelp);
    $('#modalClose').addEventListener('click', closeModal);
    $('#modalBack').addEventListener('click', (e) => { if (e.target === $('#modalBack')) closeModal(); });
    $('#btnClearLog').addEventListener('click', () => { pushHistory('Clear log'); G.log=[]; rebuildLog(); });
    $('#zoom').addEventListener('input', () => renderTrack());

    
    // Map path editor controls
    const btnPathEdit = $('#btnPathEdit');
    const btnPathReset = $('#btnPathReset');
    const pathStatus = $('#pathStatus');
    const canvas = $('#trackCanvas');

    function setPathEdit(on){
      mapEditEnabled = !!on;
      mapDragIndex = -1; mapDragging = false;
      if (btnPathEdit) btnPathEdit.classList.toggle('primary', mapEditEnabled);
      if (pathStatus){
        pathStatus.textContent = mapEditEnabled ? 'Editing (drag / Shift+Click add / Alt+Click delete)' : '';
      }
      renderTrack();
    }

    function enforceClosedPoly(poly){
      if (!Array.isArray(poly) || poly.length<4) return poly;
      // Ensure last equals first (closed loop)
      const a = poly[0], b = poly[poly.length-1];
      if (!b || a[0]!==b[0] || a[1]!==b[1]){
        poly = poly.slice();
        poly.push([a[0], a[1]]);
      }
      return poly;
    }

    function saveCurrentPoly(poly){
      poly = enforceClosedPoly(poly);
      // clamp and normalize
      poly = poly.map(p=>[clamp(+p[0],0,1), clamp(+p[1],0,1)]);
      setPolyOverride(poly);
      applyPolyOverrideToCurrentTrack();
      // Persist into custom track too if we're on custom
      if (G && G.trackPresetId==='custom'){
        try{ localStorage.setItem(TRACK_CUSTOM_KEY, JSON.stringify(G.track)); }catch(e){}
      }
      renderTrack();
    }

    function defaultPolyForCurrentPreset(){
      const pid = (G && G.trackPresetId) || 'custom';
      const preset = TRACK_LIBRARY.find(x=>x.id===pid);
      const base = preset?.track?.mapPoly || DEFAULT_TRACK.mapPoly;
      return deepClone(base || []);
    }

    if (btnPathEdit){
      btnPathEdit.addEventListener('click', ()=> setPathEdit(!mapEditEnabled));
    }
    if (btnPathReset){
      btnPathReset.addEventListener('click', ()=> {
        const poly = defaultPolyForCurrentPreset();
        // remove override record
        setPolyOverride(null);
        if (G && G.track){
          G.track.mapPoly = poly;
          if (G.trackPresetId==='custom'){
            try{ localStorage.setItem(TRACK_CUSTOM_KEY, JSON.stringify(G.track)); }catch(e){}
          }
        }
        renderTrack();
      });
    }

    function eventToNorm(e){
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width;
      const y = (e.clientY - rect.top) / rect.height;
      return [clamp(x,0,1), clamp(y,0,1), rect];
    }

    function nearestPointIndex(poly, x, y){
      let best=-1, bestD=1e9;
      for (let i=0;i<poly.length;i++){
        const dx = poly[i][0]-x, dy = poly[i][1]-y;
        const d = dx*dx + dy*dy;
        if (d < bestD){ bestD=d; best=i; }
      }
      return {idx:best, d2:bestD};
    }

    function insertPointOnNearestSegment(poly, x, y){
      // find nearest segment (i..i+1)
      let bestSeg=0, bestD=1e9, bestT=0;
      for (let i=0;i<poly.length-1;i++){
        const ax=poly[i][0], ay=poly[i][1];
        const bx=poly[i+1][0], by=poly[i+1][1];
        const vx=bx-ax, vy=by-ay;
        const wx=x-ax, wy=y-ay;
        const vv = vx*vx+vy*vy || 1e-9;
        let t = (wx*vx+wy*vy)/vv;
        t = clamp(t,0,1);
        const px = ax + vx*t, py = ay + vy*t;
        const dx=x-px, dy=y-py;
        const d = dx*dx+dy*dy;
        if (d<bestD){ bestD=d; bestSeg=i; bestT=t; }
      }
      // Insert after bestSeg, but avoid inserting between last and first duplicate closure point: insert before last
      const insertAt = Math.min(bestSeg+1, poly.length-1);
      const out = poly.slice(0, insertAt).concat([[x,y]], poly.slice(insertAt));
      return out;
    }

    if (canvas){
      canvas.addEventListener('pointerdown', (e)=>{
        if (!mapEditEnabled) return;
        e.preventDefault();
        canvas.setPointerCapture?.(e.pointerId);
        const [x,y,rect] = eventToNorm(e);
        let poly = deepClone(getPolyOverride() || (G?.track?.mapPoly) || DEFAULT_TRACK.mapPoly || []);
        if (!poly || poly.length<4) poly = defaultPolyForCurrentPreset();
        poly = enforceClosedPoly(poly);

        // Threshold in normalized units based on canvas size
        const threshPx = 18;
        const threshN = threshPx / Math.min(rect.width, rect.height);
        const {idx, d2} = nearestPointIndex(poly, x, y);

        if (e.altKey){
          // delete point (not if would drop below 4, and avoid deleting last closure point)
          if (idx>0 && idx<poly.length-1 && poly.length>5){
            poly.splice(idx,1);
            poly = enforceClosedPoly(poly);
            saveCurrentPoly(poly);
          }
          return;
        }
        if (e.shiftKey){
          // insert point on nearest segment (avoid adding if click is near existing point)
          if (Math.sqrt(d2) > threshN){
            poly = insertPointOnNearestSegment(poly, x, y);
            poly = enforceClosedPoly(poly);
            saveCurrentPoly(poly);
            mapDragIndex = Math.max(0, Math.min(poly.length-2, idx+1));
            mapDragging = true;
          }
          return;
        }

        if (Math.sqrt(d2) <= threshN){
          mapDragIndex = idx;
          mapDragging = true;
        } else {
          mapDragIndex = -1;
          mapDragging = false;
        }
        renderTrack();
      });

      canvas.addEventListener('pointermove', (e)=>{
        if (!mapEditEnabled || !mapDragging || mapDragIndex<0) return;
        e.preventDefault();
        const [x,y] = eventToNorm(e);
        let poly = deepClone(getPolyOverride() || (G?.track?.mapPoly) || defaultPolyForCurrentPreset());
        poly = enforceClosedPoly(poly);
        poly[mapDragIndex] = [x,y];
        // If editing the first point, also move the last closure point.
        if (mapDragIndex===0) poly[poly.length-1] = [x,y];
        // If editing the last closure point, mirror to first.
        if (mapDragIndex===poly.length-1) poly[0] = [x,y];

        // clamp and store without spamming localStorage too hard: store live but ok
        saveCurrentPoly(poly);
      });

      function stopDrag(e){
        if (!mapEditEnabled) return;
        if (mapDragging){
          mapDragging = false;
          mapDragIndex = -1;
          renderTrack();
        }
      }
      canvas.addEventListener('pointerup', stopDrag);
      canvas.addEventListener('pointercancel', stopDrag);
      canvas.addEventListener('pointerleave', stopDrag);
    }

// Background image loader controls (per track). This does NOT bundle copyrighted images.
    const bgFile = $('#trackBgFile');
    const btnLoad = $('#btnBgLoad');
    const btnClear = $('#btnBgClear');
    const op = $('#bgOpacity');
    const sc = $('#bgScale');
    const dx = $('#bgDx');
    const dy = $('#bgDy');
    if (btnLoad && bgFile){
      btnLoad.addEventListener('click', ()=> bgFile.click());
      bgFile.addEventListener('change', (e)=> {
        const f = e.target.files && e.target.files[0];
        if (!f) return;
        const reader = new FileReader();
        reader.onload = ()=> {
          const dataUrl = String(reader.result||'');
          const img = new Image();
          img.onload = ()=> {
            setTrackBg({ dataUrl, w: img.naturalWidth, h: img.naturalHeight, opacity: 0.85, scale: 1.0, dx: 0, dy: 0 });
          };
          img.src = dataUrl;
        };
        reader.readAsDataURL(f);
        e.target.value = '';
      });
    }
    if (btnClear){
      btnClear.addEventListener('click', ()=> setTrackBg(null));
    }
    if (op){
      op.addEventListener('input', ()=> {
        const bg = getTrackBg(); if (!bg) return;
        bg.opacity = clamp(parseInt(op.value,10)/100, 0, 1);
        setTrackBg(bg);
      });
    }
    if (sc){
      sc.addEventListener('input', ()=> {
        const bg = getTrackBg(); if (!bg) return;
        bg.scale = clamp(parseInt(sc.value,10)/100, 0.5, 2.0);
        setTrackBg(bg);
      });
    }

    if (dx){
      dx.addEventListener('input', ()=> {
        const bg = getTrackBg(); if (!bg) return;
        bg.dx = clamp(parseInt(dx.value,10)/100, -0.5, 0.5);
        setTrackBg(bg);
      });
    }
    if (dy){
      dy.addEventListener('input', ()=> {
        const bg = getTrackBg(); if (!bg) return;
        bg.dy = clamp(parseInt(dy.value,10)/100, -0.5, 0.5);
        setTrackBg(bg);
      });
    }
    updateBgUI();
  // Track view mode (Map/Strip)
  const tvm = $('#trackViewMode');
  if (tvm){
    const saved = localStorage.getItem('heat_track_view_mode');
    if (saved){ tvm.value = saved; }
    tvm.addEventListener('change', ()=>{
      localStorage.setItem('heat_track_view_mode', tvm.value);
      renderTrack();
    });
  }

    $('#btnCenter').addEventListener('click', () => {
      let p=null;
      if (G.phase === PHASE.PLANNING) p = G.players[G.planningIdx];
      if (G.phase === PHASE.RESOLUTION) p = activePlayer();
      if (p) centerOnSpace(p.pos.idx);
    });
  }

  /***********************
   * Init
   ***********************/
  loadBgStore();
    loadPolyStore();
  hookHeader();
  updateBgUI();
  newGame();

})();
</script>
</body>
</html>
